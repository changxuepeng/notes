# 一.static 关键字

static 修饰的各种类型在 类被加载时间都会首先被调用

static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途

方便在没有创建对象的情况下来进行调用（方法/变量）

1.static 方法

2.static变量 属于类本身，在类被加载的时候被初始化，只有一份

3.static 代码块 用来形成静态代码块以优化程序性能，只用执行一次即可的代码

4.静态导包

5.静态内部类

> 1、用static修饰的内部类，称为静态内部类，完全属于外部类本身，不属于外部类某一个对象
>
> 2、static关键字的作用是把修饰的成员变成类相关，而不是实例相关
>
> 3、静态内部类可以包含静态成员，也可以包含非静态成员，但是在非静态内部类中不可以声明静态成员。
>
> 4、静态类内部不可以访问外部类的实例成员，只能访问外部类的类成员，即使是静态内部类的实例方法也不能访问外部类的实例成员，只能访问外部类的静态成员
>
> 5、外部类不可以定义为静态类，Java中静态类只有一种，那就是静态内部类，顶级类不能用static 修饰
>
> 6、外部类如何调用静态内部类中的属性和方法
>
> 　　　1）外部类可以通过创建静态内部类实例的方法来调用静态内部类的非静态属性和方法
>
> 　　　2）外部类可以直接通过“ 外部类.内部类.属性（方法）” 的方式直接调用静态内部类中的静态属性和方法
>
> 7、如何创建静态内部类实例
>
> 　　　1）在非外部类中：外部类名.内部类名 name = new 外部类名.内部类名();
>
> 　　　2）在外部类中：内部类名 name = new 内部类名();

###### 误区：

> 1.static关键字不会改变类中成员的作用域
>
> 2.静态成员变量独立于对象，但是可以通过对象访问
>
> 3.static 变量不能作为局部变量

# 二、final 关键字

1.修饰 类， 此时这个类不能被继承 

> a.被final修饰的类，其内部成员变量可以根据需要设计为final 或者不是，
>
> b.被final 修饰的方法，其内部方法被隐式的制定为final final 方法。

2.修饰方法 ，被final 修饰的方法不能被重写

3.修饰成员变量，

> a.必须初始化 
>
> b.被final 修饰的成员变量 赋值 通过 直接赋值，或者 构造方法 
>
> c.如果是基本类型，值不能修改 
>
> d.如果是引用对象，地址不能修改，指向内容中的值可以修改。

# 三。 transient 

被他修饰的 变量，在 对象序列化的时候不会被序列化， HashMap  的valus   
静态变量不管是否被transient修饰都不会被序列化

# 四。**synchronized** 

>  **同步锁，使用锁的机制实现同步**
>
> **1.修饰一个代码块，同步代码块，作用对象是调用这个代码块的对象，指定对象加锁****
>
> 2.修饰一个方法，同步方法， 作用对象是调用这个方法的对象，当前对象加锁
>
> 3.修饰一个静态方法，作用对象是这个类的所有对象，当前类对象加锁
>
> 4.修饰一个类，对用对象是这个类的所有对象，当前对象加锁**
>
> 两个并发进程访问同一个对象object中的synchronized（this）同步代码时，一个时间内只有一个线程得到执行，另一个线程必须等到该线程执行完该代码块才可以执行。
>
> 当一个线程访问一个对象object中的synchronized（this）同步代码时，另一个线程可以访问该object的非同步代码块。
>
> 当一个线程访问一个对象object中的synchronized（this）同步代码时，其他线程对该object对象中的其他同步代码块的访问也被阻塞。 对象锁
>
> 注：使用该关键字，需要注意是否是对同一个对象加锁，对于静态方法或者是类，该类的所有对象同一把锁。

# 五。**throw/throws关键字**

throw 用于语句抛出异常

throws 用于可能抛出异常的声明

# 六。**volatile关键字**

> **修饰变量**保证不同线程对于这个变量进行操作时的可见性，即一个线程修改了该变量的值，该新值对于其他线程是立即可见的。如果是写操作，会导致其他CPU中对应的缓存行无效，需要到主存中读取该变量的值，
>
> 禁止进行指令重排序
>
> 加入volitile 关键字修饰的变量，会多一个lock() 前缀，可以形成一个内存屏障，可以保证指令重排序不会穿过屏障前置将对缓存的修改操作写入主存

# 七. **foreach 循环遍历 ，**

**实际使用的是迭代器**
**Iterator var2 = listStr.iterator();****while(var2.hasNext()) {**  **String s = (String)var2.next();**  **System.out.println("s = " + s);**