# 10.ThreadLocal的作用及使用

> Threadlocal不是用来解决共享对象多线程访问问题的，通过ThreadLocal的set() 方法设置到ThreadLocalMap 里的是线程自己要存储的对象，其他线程不需要去访问，也不用去访问。各个线程中ThreadLocal.ThreadLocalMap 及ThreadLocal.ThreadLocalMap 中的值都是不同的对象。

**ThreadLocal再总结**

> 1.ThreadLocal 不是集合，他不存储内容，真正存储内容的集合在Thread 中，ThreadLocal 是也给工具，一个往ThreadLocal.ThreadLocalMap 中设值 ，取值的工具
>
> 2.同步和ThreadLocal 是解决多线程问题的2种T思路，同步时数据共享的思路，ThreadLocal 是数据隔离的思路
>
> 3.同步是一种以时间换空间的思路，ThreadLocal 是一种空间换时间的思路
>
> 4.ThreadLocal 既然是与线程相关的，那么对于javaWeb 来说，ThreadLocal设置的值只在一个请求种有效，是不是和request很像。因为request 里的内容只在一次请求有效，对比下二者的区别：
>
> ​	（1）ThreadLocal 只存一个值，一个Request由于是Map形式的，可以用key-value形式存多个值
>
> ​	（2）ThreadLocal 一般用在框架，Request 一般用在表示层，Action,Servlet;
>
> 

# 11.ReentrantLock 和Condition

##### 1.ReentrantLocal

> ReentrantLocal,一个可重入的互斥锁，他具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语句，但功能更强大。

```java
import java.util.concurrent.locks.ReentrantLock;
public class ThreadDomain38 {
    ReentrantLock lock = new ReentrantLock();
     public void testMethod(){
         try{
             lock.lock();
             for (int i = 0; i < 3; i++) {
                 System.out.println(Thread.currentThread().getName()+",i="+i);
             }
         }catch (Exception e){
            e.printStackTrace();
         }finally {
             lock.unlock();
         }
     }
}
```

```java
public class MyThread38 extends Thread {
    ThreadDomain38 domain ;
    MyThread38(ThreadDomain38 domain){
        this.domain =domain;
    }
    @Override
    public void run() {
        domain.testMethod();
    }
}
```

```java
public class MyThreadMain38 {
    public static void main(String[] args) {
        ThreadDomain38 domain = new ThreadDomain38();
        MyThread38 mt1 = new MyThread38(domain);
        MyThread38 mt2 = new MyThread38(domain);
        MyThread38 mt3 = new MyThread38(domain);
        mt1.start();
        mt2.start();
        mt3.start();
    }
}
```

结果：

```
Thread-0,i=0
Thread-0,i=1
Thread-0,i=2
Thread-1,i=0
Thread-1,i=1
Thread-1,i=2
Thread-2,i=0
Thread-2,i=1
Thread-2,i=2
```

> 没有任何的交替，数据是分组打印，说明是一个线程打印完后，下一个线程才可以获取锁区打印，也说明了ReentrantLock 具有加锁的功能。

##### 2.ReentrantLock 持有的是对象监视器

reentrantLock 持有的是什么锁。

```java
public class ThreadDoman39 {
    private ReentrantLock lock = new ReentrantLock();
    public void methodA(){
        try{
            lock.lock();
            System.out.println("methodA begin--"+Thread.currentThread().getName() +",time="+System.currentTimeMillis());
            Thread.sleep(5000);
            System.out.println("methodA end--"+Thread.currentThread().getName()+",time="+System.currentTimeMillis());
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public void methodB(){
        lock.lock();
        System.out.println("methodB begin--"+Thread.currentThread().getName()+",time="+System.currentTimeMillis());
        System.out.println("methodB end--"+Thread.currentThread().getName()+",time="+System.currentTimeMillis());
        lock.unlock();
    }
}
```

```java
public class MyThread29_00 extends Thread {
    ThreadDoman39 domain ;
    MyThread29_00(ThreadDoman39 domain){
        this.domain =domain;
    }
    @Override
    public void run() {
        domain.methodA();
    }
}
```

```java
public class MyThread29_01 extends Thread {
    ThreadDoman39 domain ;
    MyThread29_01(ThreadDoman39 domain){
        this.domain =domain;
    }
    @Override
    public void run() {
        domain.methodB();
    }
}
```

```java
public class MyThreadMain39 {
    public static void main(String[] args) {
        ThreadDoman39 doman39 = new ThreadDoman39();
        MyThread29_00 mt0 = new MyThread29_00(doman39);
        MyThread29_01 mt1 = new MyThread29_01(doman39);
        mt0.start();
        mt1.start();
    }
}
```

结果：

```
methodA begin--Thread-0,time=1600417674495
methodA end--Thread-0,time=1600417679495
methodB begin--Thread-1,time=1600417679495
methodB end--Thread-1,time=1600417679495
```

将methodB() 的用synchronized 修饰

```java
public class ThreadDoman39 {
    private ReentrantLock lock = new ReentrantLock();
    public void methodA(){
        try{
            lock.lock();
            System.out.println("methodA begin--"+Thread.currentThread().getName() +",time="+System.currentTimeMillis());
            Thread.sleep(5000);
            System.out.println("methodA end--"+Thread.currentThread().getName()+",time="+System.currentTimeMillis());
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public synchronized  void methodB(){
        System.out.println("methodB begin--"+Thread.currentThread().getName()+",time="+System.currentTimeMillis());
        System.out.println("methodB end--"+Thread.currentThread().getName()+",time="+System.currentTimeMillis());
    }
}

```

结果：（不固定）

```
methodA begin--Thread-0,time=1600418842963
methodB begin--Thread-1,time=1600418842963
methodB end--Thread-1,time=1600418842963
methodA end--Thread-0,time=1600418847963
```

> ReentrantLock虽然持有对象监视器，但是和synchronized持有的对象监视器不是一个意思，两种是可以异步执行的，ReentrantLock持有的锁需要自己区unlock.

##### 3.Condition

> synchronized 与wait() 和notify()/notifyAll 方法结合可以实现等待通知，ReentrantLock同样可以，但是需要借助Condition,且Condition 具有更好的灵活性，具体体现：
>
> 1.一个Lock 里边可以创建多个Condition 实例，实现多路通知。
>
> 2.notify() 方法进行通知时，被同知线程的时候，java虚拟机随机选择，但是ReentrantLock 结合Condition 可以实现选择性的通知，这很重要，
>
> wait() 和signal()之前，必须通过 ReentrantLock .lock() 获取到锁，使用完毕后，在finally 里使用unlock() 释放锁。

```java
public class ThreadDomain40 {
    private ReentrantLock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();
    public void  await(){
        try{
            lock.lock();
            System.out.println("await时间为："+System.currentTimeMillis());
            condition.await();
            System.out.println("await结束时间为："+System.currentTimeMillis());
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public void signal(){
        try{
            lock.lock();
            condition.signal();
            System.out.println("signal的时间为："+System.currentTimeMillis());
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}
```

```java
public class MyThread40 extends Thread {
    private ThreadDomain40 domain;
    MyThread40(ThreadDomain40 domain){
        this.domain = domain;
    }
    @Override
    public void run() {
        domain.await();
    }
}

```

```java
public class Mythread40Main {
    public static void main(String[] args) throws InterruptedException {
        ThreadDomain40 domain = new ThreadDomain40();
        MyThread40 thread = new MyThread40(domain);
        thread.start();
        Thread.sleep(3000);
        domain.signal();
    }
}
```

结果：

```
await时间为：1600420688519
signal的时间为：1600420691519
await结束时间为：1600420691520
```

> Condition 的await()  方法是释放锁的。
>
> 注意要用是用一个Condition的话，多个线程被该Condition 给await() 后，需要调用Condition 的signalAll() 方法唤起所有线程。如果想单独唤醒某个线程， new 出多个Condition就可以了。

# 12.ReentrantLock 中的方法

##### 1.公平锁和非公平锁

> ReentrantLock  有个很大的优点，就是可以指定锁是公平锁还是非公平锁，公平锁表示线程获取锁的顺序是按照线程排队的顺序来分配的，而非公平锁， 就是一个种锁的抢占机制，是随机获取锁的，先来的阿未必能先拿到锁；从这个角度上看，synchronized其实就是一种非公平锁，

```java
public class ThreadDomain41 {
    private Lock lock = new ReentrantLock(true);
    public void testMethod(){
        try{
            lock.lock();
            System.out.println(Thread.currentThread().getName()+"获取到锁");
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}
```

```java
public class MyThread41 {
    public static void main(String[] args) {
        final  ThreadDomain41 domain = new ThreadDomain41();
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("◆◆◆◆◆◆线程"+Thread.currentThread().getName()+"尝试获取锁：");
                domain.testMethod();
            }
        };
        Thread[] threads = new Thread[5];
        for (int i = 0; i < 5; i++) {
            threads[i] = new Thread(runnable);
        }
        for (int i = 0; i < 5; i++) {
            threads[i].start();
        }
    }
}
```

结果：

```
◆◆◆◆◆◆线程Thread-0尝试获取锁：
◆◆◆◆◆◆线程Thread-4尝试获取锁：
◆◆◆◆◆◆线程Thread-3尝试获取锁：
◆◆◆◆◆◆线程Thread-2尝试获取锁：
Thread-0获取到锁
◆◆◆◆◆◆线程Thread-1尝试获取锁：
Thread-4获取到锁
Thread-3获取到锁
Thread-2获取到锁
Thread-1获取到锁
```

> 一执行run()方法的第一步就是尝试区获取。看到输出结果的 尝试获取锁和获取到锁阿顺序是一样的，这就是公平锁。

将  private Lock lock = new ReentrantLock(true); 种的true  改为false

结果：

```
◆◆◆◆◆◆线程Thread-0尝试获取锁：
◆◆◆◆◆◆线程Thread-2尝试获取锁：
◆◆◆◆◆◆线程Thread-1尝试获取锁：
Thread-0获取到锁
◆◆◆◆◆◆线程Thread-3尝试获取锁：
Thread-3获取到锁
◆◆◆◆◆◆线程Thread-4尝试获取锁：
Thread-4获取到锁
Thread-2获取到锁
Thread-1获取到锁
```

> 顺序不一致了

##### 2.getHoldCount() --ReentrantLock 和synchronized 一样， 锁是可以重入的

> getHoldCount()返回的就是当前线程 用lock() 锁住的次数

```java
public class ThreadDomain42 {
    private ReentrantLock lock = new ReentrantLock();
    public void methodA(){
        try{
            lock.lock();
            System.out.println("methodA getHoldCount的次数："+lock.getHoldCount());
            methodB();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public void methodB(){
        try{
            lock.lock();
            System.out.println("methodB getHoldCount的次数："+lock.getHoldCount());
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}
```

```java
public class MyThread42Main {
    public static void main(String[] args) {
        ThreadDomain42 domain = new ThreadDomain42();
        domain.methodA();
    }
}

```

结果：

```
methodA getHoldCount的次数：1
methodB getHoldCount的次数：2
```

##### 3.getQueueLength()和isFair()

> getQueueLength是获取正在等待获取此锁 锁定的线程估计数。因为此方法 遍历内部数据结构的时候，线程的数据结构可能发生变化
>
> isFair()  判断是不是公平锁。