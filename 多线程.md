# https://www.cnblogs.com/xrq730/p/4872722.html



# 1 java多线程 01

##### 1. 创建线程的方法

1. 继承Thread 类

   ```java
   public class MyThread00 extends Thread {
       @Override
       public void run() {
           for (int i = 0; i <5 ; i++) {
               System.out.println(Thread.currentThread().getName()+"在执行");
           }
       }
   }
   public class MyThread1Main {
       public static void main(String[] args) {
           MyThread00 td00 = new MyThread00();
           td00.start();
           for (int i = 0; i < 5; i++) {
               System.out.println(Thread.currentThread().getName()+"在执行");
           }
       }
   }
   
   ```

2. 实现Runnable 接口

```java
public class MyRunnable00 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i <5 ; i++) {
            System.out.println(Thread.currentThread().getName()+"在执行");
        }
    }
}

public class MyRunnable00Main {
        public static void main(String[] args) {
            MyRunnable00 td00 = new MyRunnable00();
            Thread thread = new Thread(td00);
            thread.start();
            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName()+"在执行");
            }
        }
}

```



##### 2.多线程的状态

虚拟机中的线程又6种状态,定义在Thread.State中:

###### 1.新建状态new

new 了但是没有启动的线程.。比如“Thread t = new Thread();”，t就是一个处于new 状态的线程；

###### 2.可运行状态RUNNABLE

new 出来的线程，执行了start()方法，旧处于 RUNNABLE状态；处于RUNNABLE状态的线程可能正在虚拟机中运行，也可以正在等待处理器资源，因为一个线程只有获取CPU的资源后，才可以运行其run()方法中的内容，否则等待；

###### 3.阻塞BOLCKED

如果某一个线程正在等待监视器锁，以便进入一个同步的块/方法；那么线程的状态处于阻塞BLOCKED。

###### 4.等待WAITING

某一线程因为调用不带超时的Object 的wait()方法，不带超时的Thread的join()方法，LockSupport的park() 方法，线程就会处于WAITING状态

###### 5.超时等待TIME_WAITING

某一线程因为调用了带超时时间的 Object 的wait()方法，Thread 的join() 方法，Thread的sleep() 方法，LockSupport 的parkNancos（）方法，LockSupport 的packUtil()方法，就会处于超时等待TIME_WAITING.

###### 6.终止状态TRERMINATED

线程调用终止或者run()方法执行结束，线程及处于终止状态，处于终止状态的线程不具备重新运行的能力



# 2 多线程02，Thread  中的实例方法

##### 1.**Thread类中的方法调用方式**两种方式

> ​	this.XXX()
>
> ​	这种调用方式表示的线程是 线程实例本身
>
> ​	Thread.currentThread.XXX ()或者 Thread.XXX()
>
> ​	这种调用方式表示的线程是正在执行 Thread.currentThread.XXX ()虽在代码块的线程



##### 2.Thread中的实例方法

> 从Thread 类中的实例方法和类方法的角度来讲解Thead 中的方法，这种区分的角度有助于理解多线程中的方法；
>
> 实例方法 只和实例线程(也就是new 出来的线程)挂钩，和当前运行的是哪个线程有关。

###### 1.start()

作用：通知“线程规划器”,此线程可以运行了，正在等待CPU调用线程对象的run()方法，产生一个异步执行的效果；

```java
public class MyThread002 extends Thread{
    @Override
    public void run() {
        try{
            for (int i = 0; i <3 ; i++) {
                Thread.sleep((int)(Math.random())*1000);
                System.out.println("run="+Thread.currentThread().getName());
            }
        }catch (Exception e ){
            e.printStackTrace();
        }
    }
}
public class MyThreadMain002 {
    public static void main(String[] args) {
        try{
            MyThread002 td = new MyThread002();
            td.start();
            for (int i = 0; i < 3; i++) {
                Thread.sleep((int)(Math.random())*1000);
                System.out.println("mian="+Thread.currentThread().getName());
            }
        }catch ( Exception e){
            e.printStackTrace();
        }
    }
}
```

> **CPU 执行哪个线程的代码具有不确定性**

```java
public class MyThead003 extends Thread {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
public class ThreadMain003 {
    public static void main(String[] args) {
        MyThead003  mt01 = new MyThead003();
        MyThead003  mt02 = new MyThead003();
        MyThead003  mt03 = new MyThead003();
        mt01.start();
        mt02.start();
        mt03.start();
    }
}
```

> 调用start()方法的顺序不代表，不代表线程启动的顺序，线程启动的顺序具有不确定性

###### 2.run()

> 线程开始执行，虚拟机调用的是run()方法中的内容

```java
public class ThreadMain002Run {
    public static void main(String[] args) {
        try{
            MyThread002 td = new MyThread002();
            td.run();
            for (int i = 0; i < 3; i++) {
                Thread.sleep((int)(Math.random())*1000);
                System.out.println("mian="+Thread.currentThread().getName());
            }
        }catch ( Exception e){
            e.printStackTrace();
        }
    }
}
```

结果：

```
run=main
run=main
run=main
mian=main
mian=main
mian=main
```

> 说明如果只有run() 没有start(),Thread 实例中的run() 方法是没有任何异步效果的,全部被main 函数执行。换句话说，只有run(),不调用start()方法是没有任何意义的。

###### 3.isAlive()

> 线程是否处于活动状态，只要线程启动没有终止，该方法都返回true

```java
public class MyThreadIsAlive extends Thread {
    @Override
    public void run() {
        System.out.println("isAlive="+this.isAlive());
    }
}
public class MyThreadIsAliveMain {
    public static void main(String[] args) {
        try{
            MyThreadIsAlive md = new MyThreadIsAlive();
            System.out.println("main="+md.isAlive());
            md.start();
            Thread.sleep(100);
            System.out.println("main="+md.isAlive());
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

结果

```
main=false
isAlive=true
main=false
```

###### 4.getId()

> 有一个long型的全局的唯一的线程Id生成器threadSeqNumber,每new 出一个线程都会把这个增加一次，并赋予线程的tid属性。

```java
public class GetIdThread  extends Thread{
    @Override
    public void run() {
        System.out.println("currentId="+Thread.currentThread().getId());
    }
}
public class GetIdMain {
    public static void main(String[] args)  throws Exception{

        GetIdThread  td = new GetIdThread();
        GetIdThread  td2 = new GetIdThread();
        GetIdThread  td3 = new GetIdThread();
        GetIdThread  td4 = new GetIdThread();
        GetIdThread  td5 = new GetIdThread();
        td.start();
        td2.start();
        td3.start();
        td4.start();
        td5.start();
    }
}

```

###### 5.getName()

> 我们new一个线程的时候，可以指定该线程的名字，也可以不指定。如果指定，那么线程的名字就是我们自己指定的，getName()返回的也是开发者指定的线程的名字；
>
> 如果不指定，那么Thread中有一个int型全局唯一的线程初始号生成器threadInitNum，Java先把threadInitNum自增，然后以"Thread-threadInitNum"的方式来命名新生成的线程

###### 6.getPriority() 和 setPriority(int newPriority)

> 用于获取和设置线程的优先级，优先级越高的线程，容易被CPU选择执行

```java
public class PriorityThread00 extends Thread {

    @Override
    public void run() {
        System.out.println("PriorityThread00 priorty="+this.getPriority());
    }
}

public class PriorityThread0_1 extends Thread {
    @Override
    public void run() {
        System.out.println("PriorityThread0_1 priority="+this.getPriority());
        PriorityThread00 td = new PriorityThread00();
        td.start();
    }
}

public class PriorityMain {
    public static void main(String[] args) {
        System.out.println("main thread begin priority="+Thread.currentThread().getPriority());
        System.out.println("main thread end priority="+Thread.currentThread().getPriority());
        PriorityThread0_1 pt = new PriorityThread0_1();
        pt.start();
    }
}

```

结果

```
main thread begin priority=5
main thread end priority=5
PriorityThread0_1 priority=5
PriorityThread00 priorty=5
```

> **线程默认优先级为5，如果不手动指定，那么线程优先级具有继承性，比如线程A启动线程B，那么线程B的优先级和线程A的优先级相同**

```java
public class MyThread10_0 extends Thread {
    @Override
    public void run() {
        long startTime = System.currentTimeMillis();
        // 100000 设置的过小 ，达不到效果
        for (int i = 0; i <100000 ; i++) {}
        long endTime =System.currentTimeMillis();
        System.out.println("◇◇◇◇◇ thread0 执行时间="+(endTime-startTime));
    }
}
public class MyThread10_1 extends  Thread {
    @Override
    public void run() {
        long startTime = System.currentTimeMillis();
        // 100000 设置的过小 ，达不到效果
        for (int i = 0; i <100000 ; i++) {}
        long endTime =System.currentTimeMillis();
        System.out.println("◆◆◆◆◆ thread1 执行时间="+(endTime-startTime));
    }
}
public class MyThread10Main {
    public static void main(String[] args) {
        for (int i = 0; i <5; i++) {
            MyThread10_0 td1 = new MyThread10_0();
            td1.setPriority(5);
            td1.start();
            MyThread10_1 td2 = new MyThread10_1();
            td2.setPriority(2);
            td2.start();
        }
    }
}
```

结果

```
◇◇◇◇◇ thread0 执行时间=1
◇◇◇◇◇ thread0 执行时间=1
◇◇◇◇◇ thread0 执行时间=1
◇◇◇◇◇ thread0 执行时间=1
◇◇◇◇◇ thread0 执行时间=1
◆◆◆◆◆ thread1 执行时间=6
◆◆◆◆◆ thread1 执行时间=5
◆◆◆◆◆ thread1 执行时间=5
◆◆◆◆◆ thread1 执行时间=5
◆◆◆◆◆ thread1 执行时间=5
```

> **CPU会尽量将执行资源让给优先级比较高的线程**  注意  只是尽量， 不是一定， 当 100000 设置 为1000 的时候 结果就是乱序的

###### 7.isDaeMon, setDaeMon(booleab on)

> java 中有两种线程,一种是用户线程，一种是守护线程；守护线程是一种特殊的线程，他的作用是给其线程的运行提供遍历的服务，最金典的应用便是GC线程。如果进程中不存在非守护线程，守护线程便会自动销毁，因为没有存在的必要了，为别人服务，结果服务的对象都没了，当然就销毁了。

```java
public class MyThread11 extends Thread {
    @Override
    public void run() {
        int i =0;
        try{
            while (true){
                System.out.println(i);
                i++;
                Thread.sleep(1000);
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
public class MyThread11Mian {
    public static void main(String[] args)  throws Exception{
        MyThread11 td = new MyThread11();
        td.setDaemon(true);// 这个要写在start 之前
        td.start();
        Thread.sleep(5000);
        System.out.println("我离开Thread 对象再也不打印了,离开了!");
    }
}
```

结果：

```
0
1
2
3
4
我离开Thread 对象再也不打印了,离开了!
5
```

###### 8.interrupt()

> Thread 的interrupt()方法无法中断线程

```java
public class MyThread12 extends Thread {
    @Override
    public void run() {
        for (int i = 0; i <500000 ; i++) {
            System.out.println(i);
        }
    }
}
public class MyThread12Main {
    public static void main(String[] args)  throws Exception{
        MyThread12 td = new MyThread12();
        td.start();
        Thread.sleep(2000);
        td.interrupt();
    }
}
```

结果：

```
...
499995
499996
499997
499998
499999
```

> interrupt() 的作用是：在线程受到阻塞时，抛出一个中断信号，这样线程就得以退出阻塞状态

###### 9.isInterrupted()

> 测试线程是否已中断，但不清除状态标识

###### 10.join()

> join() 方法的作用是等待线程销毁.join()方法反应了一个比较现实的问题，比如main()线程执行的时间是 1s,子线程执行的时间是10s,主线程 依赖子线程执行阿结果，这个时候怎么办呢，
>
> 方法1：可以像 生产者/消费者模型一样，设置一个缓冲区，子线程执行完把数据放到缓冲区，通知主线程，主线程去拿
>
> 方法2：就是使用join()

```java
public class MyThread13 extends Thread {
    @Override
    public void run() {
        try{
            int secondValue = (int)(Math.random()*1000);
            System.out.println(secondValue);
            Thread.sleep(secondValue);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
public class MyThread13Main {
    public static void main(String[] args) throws Exception {
        MyThread13 td = new MyThread13();
        td.start();
        td.join();
        System.out.println("在td对象执行完后执行");
    }
}

```

结果：

```
836
在td对象执行完后执行
```

> join() 方法会使调用join()方法的线程 (就是td线程)所在线程（也就是main线程）无限阻塞，直到jion()方法的线程摧毁为止，此例中main线程就会无限阻塞，直到td 线程执行完run()方法为止。
>
> join() 方法的一个重点就是要区分和sleep() 方法的区别。join(2000) 也是可以的，表示join() 方法最多等待2000 ms,两者的区别是：
>
> sleep(2000) 不释放锁，join(2000)释放锁，因为join() 方法内部使用的是wait(),所以会释放锁，看下jion()的源码就知道了：join() 和join(2000) 是一样的，无非是join(0) 而已。

```java
    public final void join() throws InterruptedException {
        join(0);
    }

public final synchronized void join(long millis)
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (millis == 0) {
            while (isAlive()) {
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }
```

# 3.多线程03，Thread中的静态方法

> Thread 类中的静态方法表示操作的线程是“正在执行静态方法所在代码块的线程”,
>
> 为什么Thread 类中要有静态方法？这样就能对CPU当前正在运行的线程进行操作

###### 1.currentThread()

> currentThread( ) 返回的是对当前 正在执行对象的引用，

```java
public class MyThread04 extends Thread {

    static {
        System.out.println("静态块的打印："+Thread.currentThread().getName());
    }
    MyThread04(){
        System.out.println("构造方法的打印："+Thread.currentThread().getName());
    }
    @Override
    public void run() {
        System.out.println("run()方法的打印:"+Thread.currentThread().getName());
    }
}

public class MyThread04Main {
    public static void main(String[] args) {
        MyThread04 mt= new MyThread04();
        mt.start();
    }
}
```

结果：

```
静态块的打印：main
构造方法的打印：main
run()方法的打印:Thread-0
```

> 线程类的静态方法 ，构造方法 是被main线程调用，而线程类的run方法 才是才是应用线程自己调用



> ​	this.XXX()
>
> ​	这种调用方式表示的线程是 线程实例本身
>
> ​	Thread.currentThread.XXX ()或者 Thread.XXX()
>
> ​	这种调用方式表示的线程是正在执行 Thread.currentThread.XXX ()所在代码块的线程

```java
public class MyThread05 extends Thread {

    MyThread05(){
        System.out.println("MyThread05-----begin");
        System.out.println("MyThread05--Thread.currentThread().getName()----"+Thread.currentThread().getName());
        System.out.println("MyThread05--this.getName----"+this.getName());
        System.out.println("MyThread05-----end");
    }

    @Override
    public void run() {
        System.out.println("run()-----begin");
        System.out.println("run()--Thread.currentThread().getName()----"+Thread.currentThread().getName());
        System.out.println("run()--this.getName----"+this.getName());
        System.out.println("run()-----end");
    }
}

```

```java
public class MyThread05Main {
    public static void main(String[] args) {
        MyThread05 td = new MyThread05();
        td.start();
    }
}
```

结果：

```
MyThread05-----begin
MyThread05--Thread.currentThread().getName()----main
MyThread05--this.getName----Thread-0
MyThread05-----end
run()-----begin
run()--Thread.currentThread().getName()----Thread-0
run()--this.getName----Thread-0
run()-----end
```

> **当前执行的Thread未必就是Thread本身**

###### 2.sleep()

> sleep() 的作用是在指定的毫秒内，让当前“**正在执行的线程**”进行休眠，这个“正在执行的线程是关键” ，指的是Thread.currentThread() 返回的线程。根据JDK Api 的说法，该线程不丢失任何 监视器的所有权，简单来说，就是如果sleep代码上下被锁了，这个锁依然在，但CPU资源会让出给其他线程。

```java
public class MyThread07  extends Thread{

    @Override
    public void run() {
        try{
            System.out.println("run  threadName---"+this.getName() +"begin");
            Thread.sleep(2000);
            System.out.println("run  threadName---"+this.getName() +"end");
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}

```

```java
public class MyThread07Main {
    public static void main(String[] args) {
        MyThread07 md = new MyThread07();
        System.out.println("run---this.name--"+System.currentTimeMillis()+"--begin");
        md.start();
        System.out.println("run---this.name--"+System.currentTimeMillis()+"--end");
    }
}

```

结果：

```java
run---this.name--1599812632800--begin
run---this.name--1599812632801--end
run  threadName---Thread-0begin //第3句打出2秒后打出第4句
run  threadName---Thread-0end
```

###### 3.yield()

> 暂停当前执行的线程，执行其他线程。这个暂停时会放弃CPU资源的，并且放弃CPU资源的阿时间不固定，有可能，刚放弃了，就又重新获取到了，也有可能，放弃了一会儿，才重新获取到

```java
public class MyThread08 extends Thread {

    @Override
    public void run() {
        long startTime = System.currentTimeMillis();
        int count=0;
        for (int i = 0; i <5000000 ; i++) {
            Thread.yield();
            count =count+i+1;
        }
        System.out.println("用时："+(System.currentTimeMillis() -startTime)+"毫秒");
    }
}
```

```java
public class MyThread08Main {
    public static void main(String[] args) {
        MyThread08 mt = new MyThread08();
        mt.start();
    }
}

```

结果：

```
用时：2178毫秒
用时：2260毫秒
用时：2217毫秒
```

###### 4.interrupt

> 测试当前线程是否中断，执行后具有将状态标识清除的功能

```java
public class MyThread09Main {
    public static void main(String[] args) {
        Thread.currentThread().interrupt();
        System.out.println("是否停止1？："+Thread.interrupted());
        System.out.println("是否停止2？："+Thread.interrupted());
        System.out.println("end!");
    }
}
```

结果：

```json
是否停止1？：true
是否停止2？：false //换句话说，如果连续两次调用该方法，那么返回的必定是false
end!
```

# 4.java 多线程4 synchronized 机制

##### **1.脏读**

> 在多线程中，难免会出现多个线程对一个对象的实例变量进行同时访问，如果不做正确的处理，那么产生的后果就是 脏读，也就是取到的数据是被修改过的

```java
public class ThreadDomain13 {

    private int num =0;

    public  void addNumber(String name){
        try{
            if("a".equals(name)){
                num =100;
                System.out.println("a set over !");
                Thread.sleep(1000);
            }else{
                num =num +100;
                System.out.println("b set over!");
            }
            System.out.println(name+"-number="+num);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread13_00 extends Thread {
    private ThreadDomain13  domain13;

    MyThread13_00(ThreadDomain13 domain13){
        this.domain13 = domain13;
    }

    @Override
    public void run() {
        domain13.addNumber("a");
    }
}
```

```java
public class MyThread13_01 extends  Thread{

    private ThreadDomain13  domain13;

    MyThread13_01(ThreadDomain13 domain13){
        this.domain13 = domain13;
    }

    @Override
    public void run() {
        domain13.addNumber("b");
    }
}
```

```java
public class MyThread13Main {
    public static void main(String[] args) {
        ThreadDomain13 doMain = new ThreadDomain13();
        MyThread13_00 mt0 = new MyThread13_00(doMain);
        MyThread13_01 mt1 = new MyThread13_01(doMain);
        mt0.start();
        mt1.start();
    }
}
```

结果

```java
a set over !
b set over!
b-number=200
a-number=200
```

> 1.mt0先执行，把num 赋值为100,	然后打印出“a set over !” ，然后睡觉
>
> 2.mt0 睡觉的时候mt1 执行了，将num 赋值为200，然后答应出 “b set over! ”，然后打印出 “b-number=200”
>
> 3.mt0 睡完觉了，由于mt0 和mt1 的num时同 一个num,此时 num 已经被改为200 ，打印出 “a-number=200”

给 addNumber(String name) 方法 添加同步

```java
public class ThreadDomain13 {

    private int num =0;

    public synchronized void  addNumber(String name){
        try{
            if("a".equals(name)){
                num =100;
                System.out.println("a set over !");
                Thread.sleep(1000);
            }else{
                num =num +100;
                System.out.println("b set over!");
            }
            System.out.println(name+"-number="+num);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

结果：

```
a set over !
a-number=100
b set over!
b-number=200
```

在同步的情况下，将main函数的 修改下

```java
public class MyThread13Main {
    public static void main(String[] args) {
        ThreadDomain13 doMain0 = new ThreadDomain13();
        ThreadDomain13 doMain1 = new ThreadDomain13();
        MyThread13_00 mt0 = new MyThread13_00(doMain0);
        MyThread13_01 mt1 = new MyThread13_01(doMain1);
        mt0.start();
        mt1.start();
    }
}
```

结果：

```
a set over !
b set over!
b-number=100
a-number=100
```

> 这里有个重要的概念，关键字synchronized 取得的锁都是对象锁，而不是把一段代码或者方法 当作锁，哪个线程先执行带synchronized关键字的方法，哪个线程就持该方法所属对象的锁，其他线程只能呈等待状态，既然叫对象锁，必然和对象有关系，所以多线程访问的必须时同一个对象。

##### **2.ynchronized方法与锁对象**

```java
public class ThreadDomain14_01   {

    public  synchronized  void methodA() throws InterruptedException {
        System.out.println("Begin methodA,threadName="+Thread.currentThread().getName());
        Thread.sleep(5000);
        System.out.println("End methodA,threadName="+Thread.currentThread().getName()+",end time ="+System.currentTimeMillis());
    }

    public void methodB() throws InterruptedException {
        System.out.println("Begin methodB,threadName="+Thread.currentThread().getName()+",start time ="+System.currentTimeMillis());
        Thread.sleep(5000);
        System.out.println("End methodB,threadName="+Thread.currentThread().getName());
    }
}
```

```java
public class MyThread14_01 extends Thread {

    public ThreadDomain14_01 td;

    MyThread14_01(ThreadDomain14_01 td){
        this.td =td;
    }
    @Override
    public void run() {
        try {
            td.methodA();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```

```java
public class MyThread14_02 extends Thread {

    public ThreadDomain14_01 td;

    MyThread14_02(ThreadDomain14_01 td){
        this.td =td;
    }
    @Override
    public void run() {
        try {
            td.methodB();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread14Main {
    public static void main(String[] args) {
        ThreadDomain14_01 td = new ThreadDomain14_01();
        MyThread14_01 td1 = new MyThread14_01(td);
        MyThread14_02 td2= new MyThread14_02(td);
        td1.setName("A");
        td2.setName("B");
        td1.start();
        td2.start();
    }
}
```

结果：

```
Begin methodA,threadName=A
Begin methodB,threadName=B,start time =1600072974384
End methodB,threadName=B
End methodA,threadName=A,end time =1600072979385
```

> 从结果上来看，第一个线程调用了实体类的 methodA() 方法，第二个线程完全可以调用实体类的methodB() 方法，

将  methodB（）也改成 同步的

```java
public class ThreadDomain14_01   {

    public  synchronized  void methodA() throws InterruptedException {
        System.out.println("Begin methodA,threadName="+Thread.currentThread().getName());
        Thread.sleep(5000);
        System.out.println("End methodA,threadName="+Thread.currentThread().getName()+",end time ="+System.currentTimeMillis());
    }

    public synchronized void methodB() throws InterruptedException {
        System.out.println("Begin methodB,threadName="+Thread.currentThread().getName()+",start time ="+System.currentTimeMillis());
        Thread.sleep(5000);
        System.out.println("End methodB,threadName="+Thread.currentThread().getName());
    }
}
```

结果：

```
Begin methodA,threadName=A
End methodA,threadName=A,end time =1600073842151
Begin methodB,threadName=B,start time =1600073842151
End methodB,threadName=B
```

> 结论：
>
> 1.A线程持有Object对象的Lock锁，B线程可以以异步的方式调用Object 的对象中的非synchronized 类型的方法。
>
> 2.A线程持有Object对象的Lock锁，B线程如果在这时调用Object 的对象的synchronized类型的方法需要等待，也就是同步。

##### **3.synchronized 锁重入**

> synchronized 具有锁重入的功能，当一个对象活得一个对象的锁以后，再次请求次对象时，可以再次获取该对象的锁

```java
public class ThreadDomain16 {
    public synchronized void print1(){
        System.out.println("ThreadDomain16.print1()");
        print2();
    }
    public synchronized void print2(){
        System.out.println("ThreadDomain16.print2()");
        print3();
    }
    public synchronized void print3(){
        System.out.println("ThreadDomain16.print3()");
    }
}
```

```java
public class MyThread16Main {
    public static void main(String[] args) {
        Runnable ra = new Runnable() {
            @Override
            public void run() {
                ThreadDomain16 td = new ThreadDomain16();
                td.print1();
            }
        };
        Thread thread = new Thread(ra);
        thread.start();
    }
}
```

结果：

```
ThreadDomain16.print1()
ThreadDomain16.print2()
ThreadDomain16.print3()
```

> 证明了对象可以再次获取自己的内部锁，这种锁重入机制 ，也支持在父子类继承环境中。

##### **4.异常自动释放锁**

> 最后一个知识点时异常，当一个线程执行的代码出现异常的时候，其持有的锁会自动释放，

```java
public class ThreadDomain17 {
    public synchronized  void testMethod(){
        try{
            System.out.println("Enter ThreadDomain17.testMethod,thread="+Thread.currentThread().getName());
            Integer i = Integer.MAX_VALUE;
            while (true){
                long lg= 2/i;
                i--;
            }
        }catch ( Exception e){
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread17 extends Thread {
    ThreadDomain17 domain17;
    MyThread17(ThreadDomain17 domain17){
        this.domain17 = domain17;
    }
    @Override
    public void run() {
        domain17.testMethod();
    }
}
```

```java
public class MyThread17Main {
    public static void main(String[] args) {
        ThreadDomain17 td = new ThreadDomain17();
        MyThread17 td1 = new MyThread17(td);
        MyThread17 td2 = new MyThread17(td);
        td1.start();
        td2.start();
    }
}
```

结果：

```
Enter ThreadDomain17.testMethod,thread=Thread-0
java.lang.ArithmeticException: / by zero
	at com.thread002.ThreadDomain17.testMethod(ThreadDomain17.java:9)
	at com.thread002.MyThread17.run(MyThread17.java:13)
Enter ThreadDomain17.testMethod,thread=Thread-1
java.lang.ArithmeticException
```

> 第一句打出来以后，程序停住了，直到Thread-0抛出异常后，Thread-1才继续执行

# 5.synchronized 锁方法块

##### 1.synchronized同步代码块

> 使用synchronized 声明方法在某些情况下是又弊端的，比如A线程调用同步方法执行一个比较长时间的任务，那么B线程必须等待比较长的时间，这种情况下可以使用synchronized同步语句块来解决问题。

```java
public class ThreadDomain18 {
    public void doSomeTings(){
        for (int i = 0; i <100 ; i++) {
            System.out.println("noSynchronized threadName ="+Thread.currentThread().getName()+",i="+(i+1));
        }
        synchronized (this){
            for (int i = 0; i <100 ; i++) {
                System.out.println("synchronized threadName ="+Thread.currentThread().getName()+",i="+(i+1));
            }
        }
    }
}
```

```java
public class MyThread18 extends Thread {
    private ThreadDomain18 td;
    MyThread18(ThreadDomain18 td){
        this.td=td;
    }
    @Override
    public void run() {
        td.doSomeTings();
    }
}
```

```java
public class MyThread18Main {
    public static void main(String[] args) {
        ThreadDomain18 domain = new ThreadDomain18();
        MyThread18 td1 = new MyThread18(domain);
        MyThread18 td2 = new MyThread18(domain);
        td1.start();
        td2.start();
    }
}
```

结果：

```
...
noSynchronized threadName =Thread-1,i=88
noSynchronized threadName =Thread-1,i=89
noSynchronized threadName =Thread-1,i=90
noSynchronized threadName =Thread-1,i=91
noSynchronized threadName =Thread-1,i=92
noSynchronized threadName =Thread-1,i=93
noSynchronized threadName =Thread-0,i=99
noSynchronized threadName =Thread-0,i=100
...
```

结果2：

```
...
synchronized threadName =Thread-0,i=96
synchronized threadName =Thread-0,i=97
synchronized threadName =Thread-0,i=98
synchronized threadName =Thread-0,i=99
synchronized threadName =Thread-0,i=100
synchronized threadName =Thread-1,i=1
synchronized threadName =Thread-1,i=2
synchronized threadName =Thread-1,i=3
synchronized threadName =Thread-1,i=4
...
```

> 结论：
>
> 1.当A线程访问对象的synchronized 代码块的时候，B线程依然可以访问对象中 非 synchronized 代码块
>
> 2当A线程访问对象的synchronized 代码块的时候，B线程如果要访问synchronized 代码块 会被阻塞，

##### 2.2个synchronzied块之间具有互斥性

> 如果线程A 访问 对象A方法的 synchronzied 犯法，线程B访问统一对象的B方法的synchronzied,会被阻塞。

```java
public class ThreadDomain19 {
    public void methodA() throws  Exception{
        synchronized (this){
            System.out.println("A begin time ="+System.currentTimeMillis());
            Thread.sleep(2000);
            System.out.println("A end time ="+System.currentTimeMillis());
        }
    }
    public void methodB() throws Exception{
        synchronized (this){
            System.out.println("B begin time ="+System.currentTimeMillis());
            System.out.println("B end time ="+System.currentTimeMillis());
        }
    }
}
```

```java
public class Mythread19_01 extends Thread {
    private ThreadDomain19 td;
    Mythread19_01(ThreadDomain19 td){
        this.td=td;
    }
    @Override
    public void run() {
        try {
            td.methodA();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Mythread19_02 extends Thread {
    private ThreadDomain19 td;
    Mythread19_02(ThreadDomain19 td){
        this.td=td;
    }
    @Override
    public void run() {
        try {
            td.methodB();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread19Main {
    public static void main(String[] args) {
        ThreadDomain19 domain = new ThreadDomain19();
        Mythread19_01 dt01 = new Mythread19_01(domain);
        Mythread19_02 dt02 = new Mythread19_02(domain);
        dt01.start();
        dt02.start();
    }
}

```

结果：

```
A begin time =1600153677636
A end time =1600153679637
B begin time =1600153679637
B end time =1600153679637
```

> synchronized 获得的是一个对象所，换句话说就是，synchronized 锁的是整个对象

##### 3.synchronized块和synchronized 方法

```java
public class ThreadDomain20 {
    public synchronized  void  otherMethod(){
        System.out.println("-----run----otherMethod");
    }
    public void doL0ongTask() throws InterruptedException {
        synchronized (this){
            for (int i = 0; i <100 ; i++) {
                System.out.println("synchronized thread="+Thread.currentThread().getName()+",i="+(i+1));
                Thread.sleep(5);
            }
        }
    }
}
```

```java
public class Mythread20_00 extends Thread {
    ThreadDomain20 td;
    Mythread20_00(ThreadDomain20 td){
        this.td =td;
    }
    @Override
    public void run() {
        try {
            td.doL0ongTask();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Mythread20_01 extends Thread {
    ThreadDomain20 td;
    Mythread20_01(ThreadDomain20 td){
        this.td =td;
    }
    @Override
    public void run() {
        try {
            td.otherMethod();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThreadMian20 {
    public static void main(String[] args) {
        ThreadDomain20 domain = new ThreadDomain20();
        Mythread20_00 mt1 = new Mythread20_00(domain);
        Mythread20_01 mt2 =new Mythread20_01(domain);
        mt1.start();
        mt2.start();
    }
}
```

结果：

```
...
synchronized thread=Thread-0,i=93
synchronized thread=Thread-0,i=94
synchronized thread=Thread-0,i=95
synchronized thread=Thread-0,i=96
synchronized thread=Thread-0,i=97
synchronized thread=Thread-0,i=98
synchronized thread=Thread-0,i=99
synchronized thread=Thread-0,i=100
-----run----otherMethod
```

> 将 otherMethod 方法的synchronized 去掉后

```
synchronized thread=Thread-0,i=1
-----run----otherMethod
synchronized thread=Thread-0,i=2
synchronized thread=Thread-0,i=3
synchronized thread=Thread-0,i=4
synchronized thread=Thread-0,i=5
...
```

> **将任意对象最为对象监视器**
>
> 总结一下前边的内容：
>
> 1.synchronized同步方法
>
> 对其他synchronized同步方法 或者synchronized(this)同步代码块呈阻塞状态
>
> 同一时间只有一个线程能执行synchronized同步方法中的内容
>
> 2.synchronized同步代码块
>
> 对其他synchronized同步方法 或者synchronized(this)同步代码块呈阻塞状态
>
> 同一时间只有一个线程能执行synchronized(this)同步代码块中的内容

###### java 还支持将任意对象作为对象监视器来实现同步功能

```java
public class ThreadDomain21 {
    private String userName;
    private String password;
    private  String anyString = new String();
    public  void setUserNameAndPassword(String userName,String password) {
        try{
            synchronized(anyString){
                System.out.println("线程名："+Thread.currentThread().getName()+",在 "+System.currentTimeMillis()+" 进入同步代码块");
                this.userName= userName;
                Thread.sleep(5000);
                this.password = password;
                System.out.println("线程名："+Thread.currentThread().getName()+",在 "+System.currentTimeMillis()+" 离开同步代码块");
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread21_00 extends Thread{
    ThreadDomain21 domain ;
    MyThread21_00(ThreadDomain21 domain){
        this.domain = domain;
    }
    @Override
    public void run() {
        domain.setUserNameAndPassword("AA","ASD");
    }
}
```

```java
public class MyThread21_01 extends Thread {
    ThreadDomain21 domain ;
    MyThread21_01(ThreadDomain21 domain){
        this.domain = domain;
    }
    @Override
    public void run() {
        domain.setUserNameAndPassword("BB","DFG");
    }
}
```

```java
public class MyThread21Main {
    public static void main(String[] args) {
        ThreadDomain21 domain = new ThreadDomain21();
        MyThread21_00 mt1 = new MyThread21_00(domain);
        MyThread21_01 mt2 = new MyThread21_01(domain);
        mt1.start();
        mt2.start();
    }
}
```

结果：

```
线程名：Thread-0,在 1600159877772 进入同步代码块
线程名：Thread-0,在 1600159882773 离开同步代码块
线程名：Thread-1,在 1600159882773 进入同步代码块
线程名：Thread-1,在 1600159887774 离开同步代码块
```

> 多个线程持有“对象监视器”为统一对象的前提下，同一时间只能有一个线程可以执行synchronized(非this对象x)代码块中的代码，
>
> 锁非this对象具有一定的优点：如果在一个对象中有多个synchronized,这时虽然能实现同步，但会受到阻塞，从而印象效率，但如果同步代码块锁的时非this对象，则synchronized(非this对象x) 代码块中的程序和同步方法时异步的，不与其他锁this 同步方法抢this锁，大大提高了运行效率。
>
> private  String anyString = new String();   这个anyString 对于 setUserNameAndPassword 时全局变量，因此监视的时同一对象，
>
> synchronized(非this对象x)，这个对象如果是实例对象的话，指的是对象的引用，只要对象的应用不变，即使改变了对象的属性，运行结果依然是同步的。

###### 细化synchronized(非this对象x)的三个结论

> synchronized(非this对象x) 写法是 将x 对象本身作为对象的监视器
>
> 1.当多个线程执行synchronized(x)  {} 代码块的内容时呈同步效果
>
> 2.当其他线程执行x对象中的synchronized 的同步方法时呈同步效果
>
> 3.当其他线程执行x对象中的synchronized （this）代码块时也呈同步效果

```java
public class MyObject {
    public synchronized  void speedPrintString(){
        System.out.println("speedPrintString--getLock,time: "
                +System.currentTimeMillis()+", run ThreadName="
                +Thread.currentThread().getName());
        System.out.println("-----------------");
        System.out.println("speedPrintString--releaseLock,time: "
                +System.currentTimeMillis()+", run ThreadName="
                +Thread.currentThread().getName());
    }
}
```

```java
public class ThreadDomain24 {
    public void testMethod1(MyObject mo){
        try{
            synchronized (mo){
                System.out.println("testMethod1--getLock,time: "
                        +System.currentTimeMillis()+", run ThreadName="
                        +Thread.currentThread().getName());
                Thread.sleep(5000);
                System.out.println("testMethod1--releaseLock,time: "
                        +System.currentTimeMillis()+", run ThreadName="
                        +Thread.currentThread().getName());
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread24_00 extends Thread {
    private  ThreadDomain24 td;
    private MyObject mo;
    MyThread24_00(ThreadDomain24 td,MyObject mo){
            this.td= td;
            this.mo=mo;
    }
    @Override
    public void run() {
        td.testMethod1(mo);
    }
}
```

```java
public class MyThread24_01 extends Thread {
    private MyObject mo;
    MyThread24_01(MyObject mo){
        this.mo=mo;
    }
    @Override
    public void run() {
        mo.speedPrintString();
    }
}
```

```java
public class MyThread24Main {
    public static void main(String[] args) {
        MyObject mo = new MyObject();
        ThreadDomain24 domain = new ThreadDomain24();
        MyThread24_00 mt1 = new MyThread24_00(domain,mo);
        MyThread24_01 mt2 = new MyThread24_01(mo);
        mt1.start();
        mt2.start();
    }
}
```

结果：

```
testMethod1--getLock,time: 1600161882532, run ThreadName=Thread-0
testMethod1--releaseLock,time: 1600161887533, run ThreadName=Thread-0
speedPrintString--getLock,time: 1600161887533, run ThreadName=Thread-1
-----------------
speedPrintString--releaseLock,time: 1600161887533, run ThreadName=Thread-1
```

> 可以看到speedPrintString 方法 必须等待testMethod1 方法执行完毕才可以执行，没有办法异步执行

# 6.synchronized 锁定类方法，volatitle关键字及其他

##### 1.同步静态方法

> synchronized 还可以应用到静态方法上，如果这么写，则代表的时对当前.java 文件对应的Class类加锁。

```java
public class ThreadDomain25 {
    public synchronized  static void  printA() {
        try {
            System.out.println("线程名为：" + Thread.currentThread().getName() + "在："
                    + System.currentTimeMillis() + "进入printA() 方法");
            Thread.sleep(5000);
            System.out.println("线程名为：" + Thread.currentThread().getName() + "在："
                    + System.currentTimeMillis() + "离开printA() 方法");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public synchronized  static void printB(){
        try {
            System.out.println("线程名为：" + Thread.currentThread().getName() + "在："
                    + System.currentTimeMillis() + "进入printB() 方法");
            System.out.println("线程名为：" + Thread.currentThread().getName() + "在："
                    + System.currentTimeMillis() + "离开printB() 方法");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public synchronized  void printC(){
        try {
            System.out.println("线程名为：" + Thread.currentThread().getName() + "在："
                    + System.currentTimeMillis() + "进入printC() 方法");
            System.out.println("线程名为：" + Thread.currentThread().getName() + "在："
                    + System.currentTimeMillis() + "离开printC() 方法");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread25_0 extends Thread {
    @Override
    public void run() {
        ThreadDomain25.printA();
    }
}

public class MyThread25_1 extends Thread {
    @Override
    public void run() {
        ThreadDomain25.printB();
    }
}

public class MyThread25_2 extends Thread {
    ThreadDomain25 td;
    MyThread25_2(ThreadDomain25 td){
        this.td=td;
    }
    @Override
    public void run() {
        td.printC();
    }
}
```

```java
public class MyThread25Main {
    public static void main(String[] args) {
        ThreadDomain25 td = new ThreadDomain25();
        MyThread25_0 mt0 = new MyThread25_0();
        MyThread25_1 mt1 = new MyThread25_1();
        MyThread25_2 mt2 = new MyThread25_2(td);
        mt0.start();
        mt1.start();
        mt2.start();
    }
}
```

结果：

```
线程名为：Thread-0在：1600164229940进入printA() 方法
线程名为：Thread-2在：1600164229941进入printC() 方法
线程名为：Thread-2在：1600164229941离开printC() 方法
线程名为：Thread-0在：1600164234942离开printA() 方法
线程名为：Thread-1在：1600164234942进入printB() 方法
线程名为：Thread-1在：1600164234942离开printB() 方法
```

> 对printC() 方法的调用和对printA()方法，printB()方法的调用时异步的，
>
> 静态同步方法和非静态同步方法持有的是不同的锁，前者是 类锁，后者是对象锁，
>
> 所谓类锁，举个例子。
>
> 假如一个类中有一个静态方法A, new 出2个类的实例 B 和 实例 C,线程D持有实例B,线程E持有实例C，
>
> 只要线程D调用方法A,那么线程E调用方法A,必须等待线程D执行完方法A后，才能继续执行。

##### 2.volatitle 关键字

```java
public class MyThread28 extends Thread {
    private boolean isRunning = true;
    public void setRunning(Boolean  isRunning){
        this.isRunning = isRunning;
    }
    public boolean isRunning(){
        return isRunning;
    }
    @Override
    public void run() {
        System.out.println("我开始运行了");
        while(isRunning==true){}
        System.out.println("线程停止了");
    }
}
```

```java
public class MyThread28Main {
    public static void main(String[] args) {
        try{
            MyThread28 mt= new MyThread28();
            mt.start();
            Thread.sleep(1000);
            mt.setRunning(false);
            System.out.println("isRunning 已设置为false 了");
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

结果：

```
我开始运行了
isRunning 已设置为false 了
```

将会一致处于运行状态

> 这里要从java的内存模型（JMM）说起。根据JMM,Java种有一块主内存，不同线程有自己的工作内存，同一个变量再主内存种只有一份，如果线程用到这个变量，自己的工作内存种有一份一样的的拷贝，每次进入线程，从主内存中拿到变量值翻入自己的工作内存中，每次结束线程将 工作内存的变量同步到主内存中。
>
> 出现打印结果 是上述，程序一致处于运行状态的原因 是主内存和工作内存数据不同步。因为执行run()方法的时候拿到了一个主内存中isRunning 的拷贝（这个时候是true）,而设置isRunning是在 main 函数中做的， 换句话说，设置isRunning 的值是主内存中的值，线程工作内存中的isRunning  的值没有刷新，一直是true ,线程就一直处于运行状态了。 

> 解决方法是 给 isRunning 加上 volatitle  关键字。加上volatile 后，每次读取isRunning  的值 的时候，都先从主内存中把isRunning 读到线程的工作内存中。每次设置 写 isRunning的时候，会将工作内存的值 同步到 主内存中

修改下 加上volatile

```java
public class MyThread28 extends Thread {
    private volatile boolean isRunning = true;
    public void setRunning(Boolean  isRunning){
        this.isRunning = isRunning;
    }
    public boolean isRunning(){
        return isRunning;
    }
    @Override
    public void run() {
        System.out.println("我开始运行了");
        while(isRunning==true){}
        System.out.println("线程停止了");
    }
}
```

结果：

```
我开始运行了
isRunning 已设置为false 了
线程停止了
```

> volatile 的作用：被volatile 修饰的变量，保证每次读取的都是最新的值。线程安全围绕可见性和原子性展开，volatile 解决的是变量在多个线程之间的 可见性，不能保证原子性。
>
> synchronized 除了保证了 原子性，还保证了可见性。因为 synchronized 无论是同步方法还是同步代码块，在执行的时候都会将主内存的东西 拷贝到 工作内存中，在同步代码执行完后，再将工作内存的数据同步到主内存中。

##### 3.原子类也无法保证线程安全

```java
public class MyThread29 extends Thread {
    ThreadDomain29 domain;
    MyThread29(ThreadDomain29 domain){
        this.domain =domain;
    }
    @Override
    public void run() {
        domain.addNumber();
    }
}
```

```java
public class ThreadDomain29 {
    public static AtomicInteger aiRef = new AtomicInteger();
    public void addNumber(){
        System.out.println(Thread.currentThread().getName()+"加了100后的结果是："+aiRef.addAndGet(100));
        aiRef.addAndGet(1);
    }
}
```

```java
public class MyThread29Main {
    public static void main(String[] args) {
        try{
            ThreadDomain29 domain = new ThreadDomain29();
            MyThread29[] threadArray = new MyThread29[5];
            for (int i = 0; i <5 ; i++) {
                threadArray[i]=new MyThread29(domain);
            }
            for (int i = 0; i < 5; i++) {
                threadArray[i].start();
            }
            Thread.sleep(1000);
            System.out.println(domain.aiRef.get());
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

结果：

```
Thread-0加了100后的结果是：100
Thread-1加了100后的结果是：200
Thread-3加了100后的结果是：402
Thread-2加了100后的结果是：301
Thread-4加了100后的结果是：503
505
```

> 最后  输出的505 是正确的，但不是我们想要的， 我们想 要结果按照顺序输出，导致这个问题的原因是 aiRef.addAndGet(100) 和
>
> aiRef.addAndGet(1)是 2个操作是可以分割的。
>
> 解决办法就是 加 addNumber 设置为 synchronized 的

```java
public class ThreadDomain29 {
    public static AtomicInteger aiRef = new AtomicInteger();
    public synchronized void addNumber(){
        System.out.println(Thread.currentThread().getName()+"加了100后的结果是："+aiRef.addAndGet(100));
        aiRef.addAndGet(1);
    }
}
```

结果：

```
Thread-0加了100后的结果是：100
Thread-3加了100后的结果是：201
Thread-2加了100后的结果是：302
Thread-1加了100后的结果是：403
Thread-4加了100后的结果是：504
505
```

# 7.死锁

##### 死锁 概念

> 
>
> 当一个线程永远的持有一个锁，并且其他线程都尝试取获取这个锁，那么他们将永远被阻塞，
>
> 如果线程A 持有锁M,并且想去获取锁L，线程B 持有锁L，并且想去获取锁M, 那么两个线程将永远的等待下去，就形成了死锁

```java
public class DeadLock {
    private  final Object  A = new Object();
    private final Object B = new Object();
    public void methodA() throws Exception{
        synchronized (A){
            System.out.println("methodA begin!");
            Thread.sleep(2000);
            synchronized (B){
                System.out.println("methodA end!");
            }
        }
    }
    public void methodB() throws Exception{
        synchronized (B){
            System.out.println("methodB begin!");
            Thread.sleep(2000);
            synchronized (A){
                System.out.println("methodB end!");
            }
        }
    }
}
```

```java
public class Thread0 extends Thread {
    DeadLock lock = new DeadLock();
    Thread0(DeadLock lock){
        this.lock = lock;
    }
    @Override
    public void run() {
        try {
            lock.methodA();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Thread1 extends Thread {
    DeadLock lock = new DeadLock();
    Thread1(DeadLock lock){
        this.lock = lock;
    }
    @Override
    public void run() {
        try {
            lock.methodB();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class DeadLockMain {
    public static void main(String[] args) {
        DeadLock lock = new DeadLock();
        Thread0  td0 = new Thread0(lock);
        Thread1  td1 = new Thread1(lock);
        td0.start();
        td1.start();
    }
}

```

结果：

```
methodB begin!
methodA begin!

```

然后就一直处于 等待状态

```
DOS 中输入
C:\Users\chang>jps

17824 DeadLockMain

C:\Users\chang>jstack 17824


Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.131-b11 mixed mode):

"DestroyJavaVM" #14 prio=5 os_prio=0 tid=0x0000000003c44800 nid=0x2ed0 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"Thread-1" #13 prio=5 os_prio=0 tid=0x000000001c094000 nid=0x2878 waiting for monitor entry [0x000000001cb7f000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at com.thread004.DeadLock.methodB(DeadLock.java:23)
        - waiting to lock <0x00000000d6438cf0> (a java.lang.Object)
        - locked <0x00000000d6438d00> (a java.lang.Object)
        at com.thread004.Thread1.run(Thread1.java:11)

"Thread-0" #12 prio=5 os_prio=0 tid=0x000000001c093000 nid=0x19e8 waiting for monitor entry [0x000000001ca7e000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at com.thread004.DeadLock.methodA(DeadLock.java:13)
        - waiting to lock <0x00000000d6438d00> (a java.lang.Object)
        - locked <0x00000000d6438cf0> (a java.lang.Object)
        at com.thread004.Thread0.run(Thread0.java:11)
```

> 先说明介绍一下每一部分的意思，以"Thread-1"为例：
>
> （1）"Thread-1"表示线程名称
>
> （2）"prio=5"表示线程优先级
>
> （3）"tid=0x000000001c094000"表示线程Id
>
> （4）nid=0x2878
>
> 线程对应的本地线程Id，这个重点说明下。因为Java线程是依附于Java虚拟机中的本地线程来运行的，实际上是本地线程在执行Java线程代码，只有本地线程才是真正的线程实体。Java代码中创建一个thread，虚拟机在运行期就会创建一个对应的本地线程，而这个本地线程才是真正的线程实体。Linux环境下可以使用"top -H -p JVM进程Id"来查看JVM进程下的本地线程（也被称作LWP）信息，注意这个本地线程是用十进制表示的，nid是用16进制表示的，转换一下就好了，0x2878对应的本地线程Id应该是10360
>
> （5） [0x000000001ca7e000]  表示线程占用的内存地址
>
> （6）java.lang.Thread.State: BLOCKED  表示线程的状态

​	解释完了每一部分的意思，看下Thread-0 处于BLOCKED 状态，Thread-1处于BLOCKED 状态：

> （1）Thread-1 获得了锁  0x00000000d6438d00 ，在等待锁 0x00000000d6438cf0
>
> （2）Thread-0 获得了锁  0x00000000d6438cf0，在等待锁 0x00000000d6438d00 

使用 kill 去 终止线程

> C:\Users\chang>taskkill /f /t /im 17824
> 成功: 已终止 PID 12120 (属于 PID 17824 子进程)的进程。
> 成功: 已终止 PID 17824 (属于 PID 7800 子进程)的进程。

##### 避免死锁的方式

> 1.让程序每次至多 能获取到一个锁
>
> 2.设计时考虑清楚，尽量减少潜在的加锁交互数量
>
> 3.既然死锁的产生是两个线程无限的等待对方的锁，那么只要在等待时间上加个限制就好了。synchronized 不具备这个功能，可以使用Lock 类中lock 方法去获取锁，这个方法可以指定一个超时时间，在等待超过时限后，返回错误信息

# 8.wait() notify()  notifyAll()

##### 1.轮询

> 线程本身是系统中独立的个体，但是线程与线程之间不是独立的个体，因为他们彼此之间要相互通信和协作。
>
> A 线程做 int 类型的 i 相加操作，B线程 等待 i =1000 的时候将i 值输出，一种方式是 while(i=1000),两个线程之间有了通信，B线程不断通过轮询来 检验 i=1000 这个条件。
>
> 这样 的话,CPU 把资源浪费在B线程的轮询 上，因为while 操作并是释放CPU资源，导致CPU 一直在这个线程中做判断操作，如果可以把轮询的时间释放出来给别的线程 就好了。

##### 2.wait/notify

在Object 对象中 有3给方法   wait() ,notify(),notifyAll  。

> wait:
>
> ​	wait() 的作用是使当前的线程进行等待，将当前线程置入 “预执行队列”，并且在wait() 所在的代码处停止，直到接到通知或者被中断，在调用wait() 前，线程必须获得该对象的锁，因此只有在同步方法或者同步代码块中 可以使用wait()
>
> notify:
>
> ​	notify()的作用是，如果有多个线程等待，那么线程规划器随机挑出一个wait 的线程，对其发出通知notify(),并是他等待回去该对象的锁。注意 “等待获取该对象锁”，意味着，即使收到通知，wait线程也不会 马上获取对象锁，必须等待nofity()方法的线程释放锁才可以，和wait()  一样，notify()也要 在同步方法/同步代码块 中使用。
>
> 总结起来：wait() 使线程停止运行，notify()使停止运行的线程继续运行。

```java
public class ThreadDomain31 {
    public void testMethod(Object lock){
        try{
            synchronized (lock){
                System.out.println(Thread.currentThread().getName()+"Begin wait()!");
                lock.wait();
                System.out.println(Thread.currentThread().getName()+"End wait()!");
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread31 extends Thread {
    Object lock;
    MyThread31(Object lock){
        this.lock =lock;
    }
    @Override
    public void run() {
        ThreadDomain31 domain  = new ThreadDomain31();
        domain.testMethod(lock);
    }
}
```

```java
public class MyThread31Main {
    public static void main(String[] args) {
        Object lock = new Object();
        MyThread31 mt1 = new MyThread31(lock);
        MyThread31 mt2 = new MyThread31(lock);
        mt1.start();
        mt2.start();
    }
}
```

结果：

```
Thread-1Begin wait()!
Thread-0Begin wait()!
```

> 如果  Thread-0 不释放锁，Thread-1 根本不会进入到同步代码块打印的

接下来 证明下notify() 不释放锁

```java
public class ThreadDomain32 {
    public void testMethod(Object lock){
        try{
            synchronized (lock){
                System.out.println(Thread.currentThread().getName()+"Begin wait()!");
                lock.wait();
                System.out.println(Thread.currentThread().getName()+"End wait()!");
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    public void synNotifyMethod(Object lock){
        try {
            synchronized (lock){
                System.out.println(Thread.currentThread().getName()+"Begin notify()!");
                lock.notify();
                Thread.sleep(5000);
                System.out.println(Thread.currentThread().getName()+"End notify()!");
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread32_00 extends Thread{
    Object lock;
    MyThread32_00(Object lock){
        this.lock = lock;
    }
    @Override
    public void run() {
        ThreadDomain32 td = new ThreadDomain32();
        td.testMethod(lock);
    }
}
```

```java
public class MyThread32_01 extends Thread {
    Object lock;
    MyThread32_01(Object lock){
        this.lock = lock;
    }
    @Override
    public void run() {
        ThreadDomain32 td = new ThreadDomain32();
        td.synNotifyMethod(lock);
    }
}
```

```java
public class MyThread32Main {
    public static void main(String[] args) {
        Object lock  = new Object();
        MyThread32_00 mt0 = new MyThread32_00(lock);
        MyThread32_01 mt1 = new MyThread32_01(lock);
        MyThread32_01 mt2 = new MyThread32_01(lock);
        mt0.start();
        mt1.start();
        mt2.start();
    }
}
```

结果：

```
Thread-0Begin wait()!
Thread-1Begin notify()!
Thread-1End notify()!
Thread-2Begin notify()!
Thread-2End notify()!
Thread-0End wait()!
```

> 如果 notify() 释放锁，那么在 在Thread-1 的notify() 方法后Thread.sleep(5000) 必定可以有其他线程进入代码块，但实际情况没有

##### 3.interrupt() 打断wait()  Thred.interrupt()

> interrupt() 方法的作用不是中断线程，而是在线程阻塞的时候给线程一个中断标识，表示该线程中断， wait() 就是阻塞场景的一种。

```java
public class ThreadDomain33 {
    public void testMethod(Object lock){
        try {
            synchronized (lock){
                System.out.println("wait()  begin:"+Thread.currentThread().getName());
                lock.wait();
                System.out.println("wait()  end:"+Thread.currentThread().getName());
            }
        }catch ( InterruptedException e){
            System.out.println("wait() 被 interrupt() 打断了");
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread33 extends Thread {
    Object lock;
    MyThread33(Object lock){
        this.lock = lock;
    }
    @Override
    public void run() {
       ThreadDomain33 thd = new ThreadDomain33();
        thd.testMethod(lock);
    }
}
```

```java
public class MyThread33Main {
    public static void main(String[] args) throws InterruptedException {
        Object lock = new Object();
        MyThread33 mt = new MyThread33(lock);
        mt.start();
        Thread.sleep(5000);
        mt.interrupt();
    }
}

```

结果：

```
wait()  begin:Thread-0
wait() 被 interrupt() 打断了
java.lang.InterruptedException
	at java.lang.Object.wait(Native Method)
	at java.lang.Object.wait(Object.java:502)
	at com.thread004.ThreadDomain33.testMethod(ThreadDomain33.java:8)
	at com.thread004.MyThread33.run(MyThread33.java:12)
```

4.notifyAll() 唤醒所有线程

```java
public class ThreadDomain34 {
    public void testMethod(Object lock){
        try{
            synchronized (lock){
                System.out.println(Thread.currentThread().getName()+"= Begin wait()");
                lock.wait();
                System.out.println(Thread.currentThread().getName()+"= End wait()");
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread34_00 extends Thread {
    Object lock;
    MyThread34_00(Object lock){
        this.lock = lock;
    }
    @Override
    public void run() {
        ThreadDomain34 domain = new ThreadDomain34();
        domain.testMethod(lock);
    }
}
```

```java
public class MyThread34_01 extends  Thread {
    Object lock;
    MyThread34_01(Object lock){
        this.lock = lock;
    }
    @Override
    public void run() {
        try{
            synchronized (lock){
                System.out.println("开始执行 lock.notifyAll()");
                lock.notifyAll();
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread34Main {
    public static void main(String[] args) {
        try{
            Object lock = new Object();
            MyThread34_00 mt1 = new MyThread34_00(lock);
            MyThread34_00 mt2 = new MyThread34_00(lock);
            MyThread34_00 mt3 = new MyThread34_00(lock);
            mt1.start();
            mt2.start();
            mt3.start();
            Thread.sleep(1000);
            MyThread34_01 mtNotifyAll = new MyThread34_01(lock);
            mtNotifyAll.start();
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}

```

结果：

```java
Thread-0= Begin wait()
Thread-1= Begin wait()
Thread-2= Begin wait()
开始执行 lock.notifyAll()
Thread-2= End wait()
Thread-1= End wait()
Thread-0= End wait()
```

> 唤醒的顺序不重要，因为 notifyAll() 会把同一资源下的所有 wait都唤醒，至于唤醒的顺序，就和线程启动的顺序一样，是虚拟机随机的。

# 9.ThreadLocal 源码剖析

##### 1.ThreadLocal 源码剖析

> ThreadLocal 类里有3个方法，set(T value), get() ,  remove();先剖析源码直到ThreadLocal 是干什么用的，再 使用，最后总结。

##### 2.三个基本理论

> 在讲解ThreadLocal 的源码前，先讲解三个基本理论
>
> 1.每个线程都有自己的ThreadLocal.ThreadLocalMap 对象，
>
> 2.每一个ThreadLocal 对象都有一个循环计数器
>
> 3.ThreadLocal.get().取值，就是根据当前的线程，获取线程中自己的ThreadLocal.ThreadLocalMap.然后 在这个Map 中根据第二点的循环计数器取得一个特定value 值

##### 3.两个数学问题

