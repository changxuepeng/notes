# https://www.cnblogs.com/xrq730/p/4872722.html



# 1 java多线程 01

##### 1. 创建线程的方法

1. 继承Thread 类

   ```java
   public class MyThread00 extends Thread {
       @Override
       public void run() {
           for (int i = 0; i <5 ; i++) {
               System.out.println(Thread.currentThread().getName()+"在执行");
           }
       }
   }
   public class MyThread1Main {
       public static void main(String[] args) {
           MyThread00 td00 = new MyThread00();
           td00.start();
           for (int i = 0; i < 5; i++) {
               System.out.println(Thread.currentThread().getName()+"在执行");
           }
       }
   }
   
   ```

2. 实现Runnable 接口

```java
public class MyRunnable00 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i <5 ; i++) {
            System.out.println(Thread.currentThread().getName()+"在执行");
        }
    }
}

public class MyRunnable00Main {
        public static void main(String[] args) {
            MyRunnable00 td00 = new MyRunnable00();
            Thread thread = new Thread(td00);
            thread.start();
            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName()+"在执行");
            }
        }
}

```



##### 2.多线程的状态

虚拟机中的线程又6种状态,定义在Thread.State中:

###### 1.新建状态new

new 了但是没有启动的线程.。比如“Thread t = new Thread();”，t就是一个处于new 状态的线程；

###### 2.可运行状态RUNNABLE

new 出来的线程，执行了start()方法，旧处于 RUNNABLE状态；处于RUNNABLE状态的线程可能正在虚拟机中运行，也可以正在等待处理器资源，因为一个线程只有获取CPU的资源后，才可以运行其run()方法中的内容，否则等待；

###### 3.阻塞BOLCKED

如果某一个线程正在等待监视器锁，以便进入一个同步的块/方法；那么线程的状态处于阻塞BLOCKED。

###### 4.等待WAITING

某一线程因为调用不带超时的Object 的wait()方法，不带超时的Thread的join()方法，LockSupport的park() 方法，线程就会处于WAITING状态

###### 5.超时等待TIME_WAITING

某一线程因为调用了带超时时间的 Object 的wait()方法，Thread 的join() 方法，Thread的sleep() 方法，LockSupport 的parkNancos（）方法，LockSupport 的packUtil()方法，就会处于超时等待TIME_WAITING.

###### 6.终止状态TRERMINATED

线程调用终止或者run()方法执行结束，线程及处于终止状态，处于终止状态的线程不具备重新运行的能力



# 2 多线程02，Thread  中的实例方法

##### 1.**Thread类中的方法调用方式**两种方式

> ​	this.XXX()
>
> ​	这种调用方式表示的线程是 线程实例本身
>
> ​	Thread.currentThread.XXX ()或者 Thread.XXX()
>
> ​	这种调用方式表示的线程是正在执行 Thread.currentThread.XXX ()虽在代码块的线程



##### 2.Thread中的实例方法

> 从Thread 类中的实例方法和类方法的角度来讲解Thead 中的方法，这种区分的角度有助于理解多线程中的方法；
>
> 实例方法 只和实例线程(也就是new 出来的线程)挂钩，和当前运行的是哪个线程有关。

###### 1.start()

作用：通知“线程规划器”,此线程可以运行了，正在等待CPU调用线程对象的run()方法，产生一个异步执行的效果；

```java
public class MyThread002 extends Thread{
    @Override
    public void run() {
        try{
            for (int i = 0; i <3 ; i++) {
                Thread.sleep((int)(Math.random())*1000);
                System.out.println("run="+Thread.currentThread().getName());
            }
        }catch (Exception e ){
            e.printStackTrace();
        }
    }
}
public class MyThreadMain002 {
    public static void main(String[] args) {
        try{
            MyThread002 td = new MyThread002();
            td.start();
            for (int i = 0; i < 3; i++) {
                Thread.sleep((int)(Math.random())*1000);
                System.out.println("mian="+Thread.currentThread().getName());
            }
        }catch ( Exception e){
            e.printStackTrace();
        }
    }
}
```

> **CPU 执行哪个线程的代码具有不确定性**

```java
public class MyThead003 extends Thread {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
public class ThreadMain003 {
    public static void main(String[] args) {
        MyThead003  mt01 = new MyThead003();
        MyThead003  mt02 = new MyThead003();
        MyThead003  mt03 = new MyThead003();
        mt01.start();
        mt02.start();
        mt03.start();
    }
}
```

> 调用start()方法的顺序不代表，不代表线程启动的顺序，线程启动的顺序具有不确定性

###### 2.run()

> 线程开始执行，虚拟机调用的是run()方法中的内容

```java
public class ThreadMain002Run {
    public static void main(String[] args) {
        try{
            MyThread002 td = new MyThread002();
            td.run();
            for (int i = 0; i < 3; i++) {
                Thread.sleep((int)(Math.random())*1000);
                System.out.println("mian="+Thread.currentThread().getName());
            }
        }catch ( Exception e){
            e.printStackTrace();
        }
    }
}
```

结果：

```
run=main
run=main
run=main
mian=main
mian=main
mian=main
```

> 说明如果只有run() 没有start(),Thread 实例中的run() 方法是没有任何异步效果的,全部被main 函数执行。换句话说，只有run(),不调用start()方法是没有任何意义的。

###### 3.isAlive()

> 线程是否处于活动状态，只要线程启动没有终止，该方法都返回true

```java
public class MyThreadIsAlive extends Thread {
    @Override
    public void run() {
        System.out.println("isAlive="+this.isAlive());
    }
}
public class MyThreadIsAliveMain {
    public static void main(String[] args) {
        try{
            MyThreadIsAlive md = new MyThreadIsAlive();
            System.out.println("main="+md.isAlive());
            md.start();
            Thread.sleep(100);
            System.out.println("main="+md.isAlive());
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

结果

```
main=false
isAlive=true
main=false
```

###### 4.getId()

> 有一个long型的全局的唯一的线程Id生成器threadSeqNumber,每new 出一个线程都会把这个增加一次，并赋予线程的tid属性。

```java
public class GetIdThread  extends Thread{
    @Override
    public void run() {
        System.out.println("currentId="+Thread.currentThread().getId());
    }
}
public class GetIdMain {
    public static void main(String[] args)  throws Exception{

        GetIdThread  td = new GetIdThread();
        GetIdThread  td2 = new GetIdThread();
        GetIdThread  td3 = new GetIdThread();
        GetIdThread  td4 = new GetIdThread();
        GetIdThread  td5 = new GetIdThread();
        td.start();
        td2.start();
        td3.start();
        td4.start();
        td5.start();
    }
}

```

###### 5.getName()

> 我们new一个线程的时候，可以指定该线程的名字，也可以不指定。如果指定，那么线程的名字就是我们自己指定的，getName()返回的也是开发者指定的线程的名字；
>
> 如果不指定，那么Thread中有一个int型全局唯一的线程初始号生成器threadInitNum，Java先把threadInitNum自增，然后以"Thread-threadInitNum"的方式来命名新生成的线程

###### 6.getPriority() 和 setPriority(int newPriority)

> 用于获取和设置线程的优先级，优先级越高的线程，容易被CPU选择执行

```java
public class PriorityThread00 extends Thread {

    @Override
    public void run() {
        System.out.println("PriorityThread00 priorty="+this.getPriority());
    }
}

public class PriorityThread0_1 extends Thread {
    @Override
    public void run() {
        System.out.println("PriorityThread0_1 priority="+this.getPriority());
        PriorityThread00 td = new PriorityThread00();
        td.start();
    }
}

public class PriorityMain {
    public static void main(String[] args) {
        System.out.println("main thread begin priority="+Thread.currentThread().getPriority());
        System.out.println("main thread end priority="+Thread.currentThread().getPriority());
        PriorityThread0_1 pt = new PriorityThread0_1();
        pt.start();
    }
}

```

结果

```
main thread begin priority=5
main thread end priority=5
PriorityThread0_1 priority=5
PriorityThread00 priorty=5
```

> **线程默认优先级为5，如果不手动指定，那么线程优先级具有继承性，比如线程A启动线程B，那么线程B的优先级和线程A的优先级相同**

```java
public class MyThread10_0 extends Thread {
    @Override
    public void run() {
        long startTime = System.currentTimeMillis();
        // 100000 设置的过小 ，达不到效果
        for (int i = 0; i <100000 ; i++) {}
        long endTime =System.currentTimeMillis();
        System.out.println("◇◇◇◇◇ thread0 执行时间="+(endTime-startTime));
    }
}
public class MyThread10_1 extends  Thread {
    @Override
    public void run() {
        long startTime = System.currentTimeMillis();
        // 100000 设置的过小 ，达不到效果
        for (int i = 0; i <100000 ; i++) {}
        long endTime =System.currentTimeMillis();
        System.out.println("◆◆◆◆◆ thread1 执行时间="+(endTime-startTime));
    }
}
public class MyThread10Main {
    public static void main(String[] args) {
        for (int i = 0; i <5; i++) {
            MyThread10_0 td1 = new MyThread10_0();
            td1.setPriority(5);
            td1.start();
            MyThread10_1 td2 = new MyThread10_1();
            td2.setPriority(2);
            td2.start();
        }
    }
}
```

结果

```
◇◇◇◇◇ thread0 执行时间=1
◇◇◇◇◇ thread0 执行时间=1
◇◇◇◇◇ thread0 执行时间=1
◇◇◇◇◇ thread0 执行时间=1
◇◇◇◇◇ thread0 执行时间=1
◆◆◆◆◆ thread1 执行时间=6
◆◆◆◆◆ thread1 执行时间=5
◆◆◆◆◆ thread1 执行时间=5
◆◆◆◆◆ thread1 执行时间=5
◆◆◆◆◆ thread1 执行时间=5
```

> **CPU会尽量将执行资源让给优先级比较高的线程**  注意  只是尽量， 不是一定， 当 100000 设置 为1000 的时候 结果就是乱序的

###### 7.isDaeMon, setDaeMon(booleab on)

> java 中有两种线程,一种是用户线程，一种是守护线程；守护线程是一种特殊的线程，他的作用是给其线程的运行提供遍历的服务，最金典的应用便是GC线程。如果进程中不存在非守护线程，守护线程便会自动销毁，因为没有存在的必要了，为别人服务，结果服务的对象都没了，当然就销毁了。

```java
public class MyThread11 extends Thread {
    @Override
    public void run() {
        int i =0;
        try{
            while (true){
                System.out.println(i);
                i++;
                Thread.sleep(1000);
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
public class MyThread11Mian {
    public static void main(String[] args)  throws Exception{
        MyThread11 td = new MyThread11();
        td.setDaemon(true);// 这个要写在start 之前
        td.start();
        Thread.sleep(5000);
        System.out.println("我离开Thread 对象再也不打印了,离开了!");
    }
}
```

结果：

```
0
1
2
3
4
我离开Thread 对象再也不打印了,离开了!
5
```

###### 8.interrupt()

> Thread 的interrupt()方法无法中断线程

```java
public class MyThread12 extends Thread {
    @Override
    public void run() {
        for (int i = 0; i <500000 ; i++) {
            System.out.println(i);
        }
    }
}
public class MyThread12Main {
    public static void main(String[] args)  throws Exception{
        MyThread12 td = new MyThread12();
        td.start();
        Thread.sleep(2000);
        td.interrupt();
    }
}
```

结果：

```
...
499995
499996
499997
499998
499999
```

> interrupt() 的作用是：在线程受到阻塞时，抛出一个中断信号，这样线程就得以退出阻塞状态

###### 9.isInterrupted()

> 测试线程是否已中断，但不清除状态标识

###### 10.join()

> join() 方法的作用是等待线程销毁.join()方法反应了一个比较现实的问题，比如main()线程执行的时间是 1s,子线程执行的时间是10s,主线程 依赖子线程执行阿结果，这个时候怎么办呢，
>
> 方法1：可以像 生产者/消费者模型一样，设置一个缓冲区，子线程执行完把数据放到缓冲区，通知主线程，主线程去拿
>
> 方法2：就是使用join()

```java
public class MyThread13 extends Thread {
    @Override
    public void run() {
        try{
            int secondValue = (int)(Math.random()*1000);
            System.out.println(secondValue);
            Thread.sleep(secondValue);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
public class MyThread13Main {
    public static void main(String[] args) throws Exception {
        MyThread13 td = new MyThread13();
        td.start();
        td.join();
        System.out.println("在td对象执行完后执行");
    }
}

```

结果：

```
836
在td对象执行完后执行
```

> join() 方法会使调用join()方法的线程 (就是td线程)所在线程（也就是main线程）无限阻塞，直到jion()方法的线程摧毁为止，此例中main线程就会无限阻塞，直到td 线程执行完run()方法为止。
>
> join() 方法的一个重点就是要区分和sleep() 方法的区别。join(2000) 也是可以的，表示join() 方法最多等待2000 ms,两者的区别是：
>
> sleep(2000) 不释放锁，join(2000)释放锁，因为join() 方法内部使用的是wait(),所以会释放锁，看下jion()的源码就知道了：join() 和join(2000) 是一样的，无非是join(0) 而已。

```java
    public final void join() throws InterruptedException {
        join(0);
    }

public final synchronized void join(long millis)
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (millis == 0) {
            while (isAlive()) {
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }
```

# 3.多线程03，Thread中的静态方法

> Thread 类中的静态方法表示操作的线程是“正在执行静态方法所在代码块的线程”,
>
> 为什么Thread 类中要有静态方法？这样就能对CPU当前正在运行的线程进行操作

###### 1.currentThread()

> currentThread( ) 返回的是对当前 正在执行对象的引用，

```java
public class MyThread04 extends Thread {

    static {
        System.out.println("静态块的打印："+Thread.currentThread().getName());
    }
    MyThread04(){
        System.out.println("构造方法的打印："+Thread.currentThread().getName());
    }
    @Override
    public void run() {
        System.out.println("run()方法的打印:"+Thread.currentThread().getName());
    }
}

public class MyThread04Main {
    public static void main(String[] args) {
        MyThread04 mt= new MyThread04();
        mt.start();
    }
}
```

结果：

```
静态块的打印：main
构造方法的打印：main
run()方法的打印:Thread-0
```

> 线程类的静态方法 ，构造方法 是被main线程调用，而线程类的run方法 才是才是应用线程自己调用



> ​	this.XXX()
>
> ​	这种调用方式表示的线程是 线程实例本身
>
> ​	Thread.currentThread.XXX ()或者 Thread.XXX()
>
> ​	这种调用方式表示的线程是正在执行 Thread.currentThread.XXX ()所在代码块的线程

```java
public class MyThread05 extends Thread {

    MyThread05(){
        System.out.println("MyThread05-----begin");
        System.out.println("MyThread05--Thread.currentThread().getName()----"+Thread.currentThread().getName());
        System.out.println("MyThread05--this.getName----"+this.getName());
        System.out.println("MyThread05-----end");
    }

    @Override
    public void run() {
        System.out.println("run()-----begin");
        System.out.println("run()--Thread.currentThread().getName()----"+Thread.currentThread().getName());
        System.out.println("run()--this.getName----"+this.getName());
        System.out.println("run()-----end");
    }
}

```

```java
public class MyThread05Main {
    public static void main(String[] args) {
        MyThread05 td = new MyThread05();
        td.start();
    }
}
```

结果：

```
MyThread05-----begin
MyThread05--Thread.currentThread().getName()----main
MyThread05--this.getName----Thread-0
MyThread05-----end
run()-----begin
run()--Thread.currentThread().getName()----Thread-0
run()--this.getName----Thread-0
run()-----end
```

> **当前执行的Thread未必就是Thread本身**

###### 2.sleep()

> sleep() 的作用是在指定的毫秒内，让当前“**正在执行的线程**”进行休眠，这个“正在执行的线程是关键” ，指的是Thread.currentThread() 返回的线程。根据JDK Api 的说法，该线程不丢失任何 监视器的所有权，简单来说，就是如果sleep代码上下被锁了，这个锁依然在，但CPU资源会让出给其他线程。

```java
public class MyThread07  extends Thread{

    @Override
    public void run() {
        try{
            System.out.println("run  threadName---"+this.getName() +"begin");
            Thread.sleep(2000);
            System.out.println("run  threadName---"+this.getName() +"end");
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}

```

```java
public class MyThread07Main {
    public static void main(String[] args) {
        MyThread07 md = new MyThread07();
        System.out.println("run---this.name--"+System.currentTimeMillis()+"--begin");
        md.start();
        System.out.println("run---this.name--"+System.currentTimeMillis()+"--end");
    }
}

```

结果：

```java
run---this.name--1599812632800--begin
run---this.name--1599812632801--end
run  threadName---Thread-0begin //第3句打出2秒后打出第4句
run  threadName---Thread-0end
```

###### 3.yield()

> 暂停当前执行的线程，执行其他线程。这个暂停时会放弃CPU资源的，并且放弃CPU资源的阿时间不固定，有可能，刚放弃了，就又重新获取到了，也有可能，放弃了一会儿，才重新获取到

```java
public class MyThread08 extends Thread {

    @Override
    public void run() {
        long startTime = System.currentTimeMillis();
        int count=0;
        for (int i = 0; i <5000000 ; i++) {
            Thread.yield();
            count =count+i+1;
        }
        System.out.println("用时："+(System.currentTimeMillis() -startTime)+"毫秒");
    }
}
```

```java
public class MyThread08Main {
    public static void main(String[] args) {
        MyThread08 mt = new MyThread08();
        mt.start();
    }
}

```

结果：

```
用时：2178毫秒
用时：2260毫秒
用时：2217毫秒
```

###### 4.interrupt

> 测试当前线程是否中断，执行后具有将状态标识清除的功能

```java
public class MyThread09Main {
    public static void main(String[] args) {
        Thread.currentThread().interrupt();
        System.out.println("是否停止1？："+Thread.interrupted());
        System.out.println("是否停止2？："+Thread.interrupted());
        System.out.println("end!");
    }
}
```

结果：

```json
是否停止1？：true
是否停止2？：false //换句话说，如果连续两次调用该方法，那么返回的必定是false
end!
```

# 4.java 多线程4 synchronized 机制

##### **1.脏读**

> 在多线程中，难免会出现多个线程对一个对象的实例变量进行同时访问，如果不做正确的处理，那么产生的后果就是 脏读，也就是取到的数据是被修改过的

```java
public class ThreadDomain13 {

    private int num =0;

    public  void addNumber(String name){
        try{
            if("a".equals(name)){
                num =100;
                System.out.println("a set over !");
                Thread.sleep(1000);
            }else{
                num =num +100;
                System.out.println("b set over!");
            }
            System.out.println(name+"-number="+num);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread13_00 extends Thread {
    private ThreadDomain13  domain13;

    MyThread13_00(ThreadDomain13 domain13){
        this.domain13 = domain13;
    }

    @Override
    public void run() {
        domain13.addNumber("a");
    }
}
```

```java
public class MyThread13_01 extends  Thread{

    private ThreadDomain13  domain13;

    MyThread13_01(ThreadDomain13 domain13){
        this.domain13 = domain13;
    }

    @Override
    public void run() {
        domain13.addNumber("b");
    }
}
```

```java
public class MyThread13Main {
    public static void main(String[] args) {
        ThreadDomain13 doMain = new ThreadDomain13();
        MyThread13_00 mt0 = new MyThread13_00(doMain);
        MyThread13_01 mt1 = new MyThread13_01(doMain);
        mt0.start();
        mt1.start();
    }
}
```

结果

```java
a set over !
b set over!
b-number=200
a-number=200
```

> 1.mt0先执行，把num 赋值为100,	然后打印出“a set over !” ，然后睡觉
>
> 2.mt0 睡觉的时候mt1 执行了，将num 赋值为200，然后答应出 “b set over! ”，然后打印出 “b-number=200”
>
> 3.mt0 睡完觉了，由于mt0 和mt1 的num时同 一个num,此时 num 已经被改为200 ，打印出 “a-number=200”

给 addNumber(String name) 方法 添加同步

```java
public class ThreadDomain13 {

    private int num =0;

    public synchronized void  addNumber(String name){
        try{
            if("a".equals(name)){
                num =100;
                System.out.println("a set over !");
                Thread.sleep(1000);
            }else{
                num =num +100;
                System.out.println("b set over!");
            }
            System.out.println(name+"-number="+num);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

结果：

```
a set over !
a-number=100
b set over!
b-number=200
```

在同步的情况下，将main函数的 修改下

```java
public class MyThread13Main {
    public static void main(String[] args) {
        ThreadDomain13 doMain0 = new ThreadDomain13();
        ThreadDomain13 doMain1 = new ThreadDomain13();
        MyThread13_00 mt0 = new MyThread13_00(doMain0);
        MyThread13_01 mt1 = new MyThread13_01(doMain1);
        mt0.start();
        mt1.start();
    }
}
```

结果：

```
a set over !
b set over!
b-number=100
a-number=100
```

> 这里有个重要的概念，关键字synchronized 取得的锁都是对象锁，而不是把一段代码或者方法 当作锁，哪个线程先执行带synchronized关键字的方法，哪个线程就持该方法所属对象的锁，其他线程只能呈等待状态，既然叫对象锁，必然和对象有关系，所以多线程访问的必须时同一个对象。

##### **2.ynchronized方法与锁对象**

```java
public class ThreadDomain14_01   {

    public  synchronized  void methodA() throws InterruptedException {
        System.out.println("Begin methodA,threadName="+Thread.currentThread().getName());
        Thread.sleep(5000);
        System.out.println("End methodA,threadName="+Thread.currentThread().getName()+",end time ="+System.currentTimeMillis());
    }

    public void methodB() throws InterruptedException {
        System.out.println("Begin methodB,threadName="+Thread.currentThread().getName()+",start time ="+System.currentTimeMillis());
        Thread.sleep(5000);
        System.out.println("End methodB,threadName="+Thread.currentThread().getName());
    }
}
```

```java
public class MyThread14_01 extends Thread {

    public ThreadDomain14_01 td;

    MyThread14_01(ThreadDomain14_01 td){
        this.td =td;
    }
    @Override
    public void run() {
        try {
            td.methodA();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```

```java
public class MyThread14_02 extends Thread {

    public ThreadDomain14_01 td;

    MyThread14_02(ThreadDomain14_01 td){
        this.td =td;
    }
    @Override
    public void run() {
        try {
            td.methodB();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread14Main {
    public static void main(String[] args) {
        ThreadDomain14_01 td = new ThreadDomain14_01();
        MyThread14_01 td1 = new MyThread14_01(td);
        MyThread14_02 td2= new MyThread14_02(td);
        td1.setName("A");
        td2.setName("B");
        td1.start();
        td2.start();
    }
}
```

结果：

```
Begin methodA,threadName=A
Begin methodB,threadName=B,start time =1600072974384
End methodB,threadName=B
End methodA,threadName=A,end time =1600072979385
```

> 从结果上来看，第一个线程调用了实体类的 methodA() 方法，第二个线程完全可以调用实体类的methodB() 方法，

将  methodB（）也改成 同步的

```java
public class ThreadDomain14_01   {

    public  synchronized  void methodA() throws InterruptedException {
        System.out.println("Begin methodA,threadName="+Thread.currentThread().getName());
        Thread.sleep(5000);
        System.out.println("End methodA,threadName="+Thread.currentThread().getName()+",end time ="+System.currentTimeMillis());
    }

    public synchronized void methodB() throws InterruptedException {
        System.out.println("Begin methodB,threadName="+Thread.currentThread().getName()+",start time ="+System.currentTimeMillis());
        Thread.sleep(5000);
        System.out.println("End methodB,threadName="+Thread.currentThread().getName());
    }
}
```

结果：

```
Begin methodA,threadName=A
End methodA,threadName=A,end time =1600073842151
Begin methodB,threadName=B,start time =1600073842151
End methodB,threadName=B
```

> 结论：
>
> 1.A线程持有Object对象的Lock锁，B线程可以以异步的方式调用Object 的对象中的非synchronized 类型的方法。
>
> 2.A线程持有Object对象的Lock锁，B线程如果在这时调用Object 的对象的synchronized类型的方法需要等待，也就是同步。

##### **3.synchronized 锁重入**

> synchronized 具有锁重入的功能，当一个对象活得一个对象的锁以后，再次请求次对象时，可以再次获取该对象的锁

```java
public class ThreadDomain16 {
    public synchronized void print1(){
        System.out.println("ThreadDomain16.print1()");
        print2();
    }
    public synchronized void print2(){
        System.out.println("ThreadDomain16.print2()");
        print3();
    }
    public synchronized void print3(){
        System.out.println("ThreadDomain16.print3()");
    }
}
```

```java
public class MyThread16Main {
    public static void main(String[] args) {
        Runnable ra = new Runnable() {
            @Override
            public void run() {
                ThreadDomain16 td = new ThreadDomain16();
                td.print1();
            }
        };
        Thread thread = new Thread(ra);
        thread.start();
    }
}
```

结果：

```
ThreadDomain16.print1()
ThreadDomain16.print2()
ThreadDomain16.print3()
```

> 证明了对象可以再次获取自己的内部锁，这种锁重入机制 ，也支持在父子类继承环境中。

##### **4.异常自动释放锁**

> 最后一个知识点时异常，当一个线程执行的代码出现异常的时候，其持有的锁会自动释放，

```java
public class ThreadDomain17 {
    public synchronized  void testMethod(){
        try{
            System.out.println("Enter ThreadDomain17.testMethod,thread="+Thread.currentThread().getName());
            Integer i = Integer.MAX_VALUE;
            while (true){
                long lg= 2/i;
                i--;
            }
        }catch ( Exception e){
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread17 extends Thread {
    ThreadDomain17 domain17;
    MyThread17(ThreadDomain17 domain17){
        this.domain17 = domain17;
    }
    @Override
    public void run() {
        domain17.testMethod();
    }
}
```

```java
public class MyThread17Main {
    public static void main(String[] args) {
        ThreadDomain17 td = new ThreadDomain17();
        MyThread17 td1 = new MyThread17(td);
        MyThread17 td2 = new MyThread17(td);
        td1.start();
        td2.start();
    }
}
```

结果：

```
Enter ThreadDomain17.testMethod,thread=Thread-0
java.lang.ArithmeticException: / by zero
	at com.thread002.ThreadDomain17.testMethod(ThreadDomain17.java:9)
	at com.thread002.MyThread17.run(MyThread17.java:13)
Enter ThreadDomain17.testMethod,thread=Thread-1
java.lang.ArithmeticException
```

> 第一句打出来以后，程序停住了，直到Thread-0抛出异常后，Thread-1才继续执行

# 5.synchronized 锁方法块

##### 1.synchronized同步代码块

> 使用synchronized 声明方法在某些情况下是又弊端的，比如A线程调用同步方法执行一个比较长时间的任务，那么B线程必须等待比较长的时间，这种情况下可以使用synchronized同步语句块来解决问题。

```java
public class ThreadDomain18 {
    public void doSomeTings(){
        for (int i = 0; i <100 ; i++) {
            System.out.println("noSynchronized threadName ="+Thread.currentThread().getName()+",i="+(i+1));
        }
        synchronized (this){
            for (int i = 0; i <100 ; i++) {
                System.out.println("synchronized threadName ="+Thread.currentThread().getName()+",i="+(i+1));
            }
        }
    }
}
```

```java
public class MyThread18 extends Thread {
    private ThreadDomain18 td;
    MyThread18(ThreadDomain18 td){
        this.td=td;
    }
    @Override
    public void run() {
        td.doSomeTings();
    }
}
```

```java
public class MyThread18Main {
    public static void main(String[] args) {
        ThreadDomain18 domain = new ThreadDomain18();
        MyThread18 td1 = new MyThread18(domain);
        MyThread18 td2 = new MyThread18(domain);
        td1.start();
        td2.start();
    }
}
```

结果：

```
...
noSynchronized threadName =Thread-1,i=88
noSynchronized threadName =Thread-1,i=89
noSynchronized threadName =Thread-1,i=90
noSynchronized threadName =Thread-1,i=91
noSynchronized threadName =Thread-1,i=92
noSynchronized threadName =Thread-1,i=93
noSynchronized threadName =Thread-0,i=99
noSynchronized threadName =Thread-0,i=100
...
```

结果2：

```
...
synchronized threadName =Thread-0,i=96
synchronized threadName =Thread-0,i=97
synchronized threadName =Thread-0,i=98
synchronized threadName =Thread-0,i=99
synchronized threadName =Thread-0,i=100
synchronized threadName =Thread-1,i=1
synchronized threadName =Thread-1,i=2
synchronized threadName =Thread-1,i=3
synchronized threadName =Thread-1,i=4
...
```

> 结论：
>
> 1.当A线程访问对象的synchronized 代码块的时候，B线程依然可以访问对象中 非 synchronized 代码块
>
> 2当A线程访问对象的synchronized 代码块的时候，B线程如果要访问synchronized 代码块 会被阻塞，

##### 2.2个synchronzied块之间具有互斥性

> 如果线程A 访问 对象A方法的 synchronzied 犯法，线程B访问统一对象的B方法的synchronzied,会被阻塞。

```java
public class ThreadDomain19 {
    public void methodA() throws  Exception{
        synchronized (this){
            System.out.println("A begin time ="+System.currentTimeMillis());
            Thread.sleep(2000);
            System.out.println("A end time ="+System.currentTimeMillis());
        }
    }
    public void methodB() throws Exception{
        synchronized (this){
            System.out.println("B begin time ="+System.currentTimeMillis());
            System.out.println("B end time ="+System.currentTimeMillis());
        }
    }
}
```

```java
public class Mythread19_01 extends Thread {
    private ThreadDomain19 td;
    Mythread19_01(ThreadDomain19 td){
        this.td=td;
    }
    @Override
    public void run() {
        try {
            td.methodA();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Mythread19_02 extends Thread {
    private ThreadDomain19 td;
    Mythread19_02(ThreadDomain19 td){
        this.td=td;
    }
    @Override
    public void run() {
        try {
            td.methodB();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread19Main {
    public static void main(String[] args) {
        ThreadDomain19 domain = new ThreadDomain19();
        Mythread19_01 dt01 = new Mythread19_01(domain);
        Mythread19_02 dt02 = new Mythread19_02(domain);
        dt01.start();
        dt02.start();
    }
}

```

结果：

```
A begin time =1600153677636
A end time =1600153679637
B begin time =1600153679637
B end time =1600153679637
```

> synchronized 获得的是一个对象所，换句话说就是，synchronized 锁的是整个对象

##### 3.synchronized块和synchronized 方法

```java
public class ThreadDomain20 {
    public synchronized  void  otherMethod(){
        System.out.println("-----run----otherMethod");
    }
    public void doL0ongTask() throws InterruptedException {
        synchronized (this){
            for (int i = 0; i <100 ; i++) {
                System.out.println("synchronized thread="+Thread.currentThread().getName()+",i="+(i+1));
                Thread.sleep(5);
            }
        }
    }
}
```

```java
public class Mythread20_00 extends Thread {
    ThreadDomain20 td;
    Mythread20_00(ThreadDomain20 td){
        this.td =td;
    }
    @Override
    public void run() {
        try {
            td.doL0ongTask();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Mythread20_01 extends Thread {
    ThreadDomain20 td;
    Mythread20_01(ThreadDomain20 td){
        this.td =td;
    }
    @Override
    public void run() {
        try {
            td.otherMethod();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThreadMian20 {
    public static void main(String[] args) {
        ThreadDomain20 domain = new ThreadDomain20();
        Mythread20_00 mt1 = new Mythread20_00(domain);
        Mythread20_01 mt2 =new Mythread20_01(domain);
        mt1.start();
        mt2.start();
    }
}
```

结果：

```
...
synchronized thread=Thread-0,i=93
synchronized thread=Thread-0,i=94
synchronized thread=Thread-0,i=95
synchronized thread=Thread-0,i=96
synchronized thread=Thread-0,i=97
synchronized thread=Thread-0,i=98
synchronized thread=Thread-0,i=99
synchronized thread=Thread-0,i=100
-----run----otherMethod
```

> 将 otherMethod 方法的synchronized 去掉后

```
synchronized thread=Thread-0,i=1
-----run----otherMethod
synchronized thread=Thread-0,i=2
synchronized thread=Thread-0,i=3
synchronized thread=Thread-0,i=4
synchronized thread=Thread-0,i=5
...
```

> **将任意对象最为对象监视器**
>
> 总结一下前边的内容：
>
> 1.synchronized同步方法
>
> 对其他synchronized同步方法 或者synchronized(this)同步代码块呈阻塞状态
>
> 同一时间只有一个线程能执行synchronized同步方法中的内容
>
> 2.synchronized同步代码块
>
> 对其他synchronized同步方法 或者synchronized(this)同步代码块呈阻塞状态
>
> 同一时间只有一个线程能执行synchronized(this)同步代码块中的内容

###### java 还支持将任意对象作为对象监视器来实现同步功能

```java
public class ThreadDomain21 {
    private String userName;
    private String password;
    private  String anyString = new String();
    public  void setUserNameAndPassword(String userName,String password) {
        try{
            synchronized(anyString){
                System.out.println("线程名："+Thread.currentThread().getName()+",在 "+System.currentTimeMillis()+" 进入同步代码块");
                this.userName= userName;
                Thread.sleep(5000);
                this.password = password;
                System.out.println("线程名："+Thread.currentThread().getName()+",在 "+System.currentTimeMillis()+" 离开同步代码块");
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread21_00 extends Thread{
    ThreadDomain21 domain ;
    MyThread21_00(ThreadDomain21 domain){
        this.domain = domain;
    }
    @Override
    public void run() {
        domain.setUserNameAndPassword("AA","ASD");
    }
}
```

```java
public class MyThread21_01 extends Thread {
    ThreadDomain21 domain ;
    MyThread21_01(ThreadDomain21 domain){
        this.domain = domain;
    }
    @Override
    public void run() {
        domain.setUserNameAndPassword("BB","DFG");
    }
}
```

```java
public class MyThread21Main {
    public static void main(String[] args) {
        ThreadDomain21 domain = new ThreadDomain21();
        MyThread21_00 mt1 = new MyThread21_00(domain);
        MyThread21_01 mt2 = new MyThread21_01(domain);
        mt1.start();
        mt2.start();
    }
}
```

结果：

```
线程名：Thread-0,在 1600159877772 进入同步代码块
线程名：Thread-0,在 1600159882773 离开同步代码块
线程名：Thread-1,在 1600159882773 进入同步代码块
线程名：Thread-1,在 1600159887774 离开同步代码块
```

> 多个线程持有“对象监视器”为统一对象的前提下，同一时间只能有一个线程可以执行synchronized(非this对象x)代码块中的代码，
>
> 锁非this对象具有一定的优点：如果在一个对象中有多个synchronized,这时虽然能实现同步，但会受到阻塞，从而印象效率，但如果同步代码块锁的时非this对象，则synchronized(非this对象x) 代码块中的程序和同步方法时异步的，不与其他锁this 同步方法抢this锁，大大提高了运行效率。
>
> private  String anyString = new String();   这个anyString 对于 setUserNameAndPassword 时全局变量，因此监视的时同一对象，
>
> synchronized(非this对象x)，这个对象如果是实例对象的话，指的是对象的引用，只要对象的应用不变，即使改变了对象的属性，运行结果依然是同步的。

###### 细化synchronized(非this对象x)的三个结论

> synchronized(非this对象x) 写法是 将x 对象本身作为对象的监视器
>
> 1.当多个线程执行synchronized(x)  {} 代码块的内容时呈同步效果
>
> 2.当其他线程执行x对象中的synchronized 的同步方法时呈同步效果
>
> 3.当其他线程执行x对象中的synchronized （this）代码块时也呈同步效果

```java
public class MyObject {
    public synchronized  void speedPrintString(){
        System.out.println("speedPrintString--getLock,time: "
                +System.currentTimeMillis()+", run ThreadName="
                +Thread.currentThread().getName());
        System.out.println("-----------------");
        System.out.println("speedPrintString--releaseLock,time: "
                +System.currentTimeMillis()+", run ThreadName="
                +Thread.currentThread().getName());
    }
}
```

```java
public class ThreadDomain24 {
    public void testMethod1(MyObject mo){
        try{
            synchronized (mo){
                System.out.println("testMethod1--getLock,time: "
                        +System.currentTimeMillis()+", run ThreadName="
                        +Thread.currentThread().getName());
                Thread.sleep(5000);
                System.out.println("testMethod1--releaseLock,time: "
                        +System.currentTimeMillis()+", run ThreadName="
                        +Thread.currentThread().getName());
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread24_00 extends Thread {
    private  ThreadDomain24 td;
    private MyObject mo;
    MyThread24_00(ThreadDomain24 td,MyObject mo){
            this.td= td;
            this.mo=mo;
    }
    @Override
    public void run() {
        td.testMethod1(mo);
    }
}
```

```java
public class MyThread24_01 extends Thread {
    private MyObject mo;
    MyThread24_01(MyObject mo){
        this.mo=mo;
    }
    @Override
    public void run() {
        mo.speedPrintString();
    }
}
```

```java
public class MyThread24Main {
    public static void main(String[] args) {
        MyObject mo = new MyObject();
        ThreadDomain24 domain = new ThreadDomain24();
        MyThread24_00 mt1 = new MyThread24_00(domain,mo);
        MyThread24_01 mt2 = new MyThread24_01(mo);
        mt1.start();
        mt2.start();
    }
}
```

结果：

```
testMethod1--getLock,time: 1600161882532, run ThreadName=Thread-0
testMethod1--releaseLock,time: 1600161887533, run ThreadName=Thread-0
speedPrintString--getLock,time: 1600161887533, run ThreadName=Thread-1
-----------------
speedPrintString--releaseLock,time: 1600161887533, run ThreadName=Thread-1
```

> 可以看到speedPrintString 方法 必须等待testMethod1 方法执行完毕才可以执行，没有办法异步执行

# 6.synchronized 锁定类方法，volatitle关键字及其他

